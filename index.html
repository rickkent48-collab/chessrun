<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ChessRun</title>
  <style>
    :root{
      --board-cols: 8;
      --board-rows: 11;
      --square-size: min(10.5vw, 48px);
      --light: #e7cfa3;
      --dark:  #b17a45;
      --text:  #2b1a10;
      --hl:    #f7d86b;
      --bg:    #f6efe5;
    }
    html,body{ margin:0; padding:0; background:var(--bg); color:var(--text);
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    .wrap{ display:flex; flex-direction:column; align-items:center; min-height:100vh; gap:10px; padding:10px 10px 24px; }
    .hud{ width:calc(var(--square-size) * var(--board-cols)); max-width:95vw;
      display:grid; grid-template-columns: 1fr 1fr 1fr; align-items:center; font-weight:700; }
    .hud .title{ justify-self:start; background:linear-gradient(180deg, #8b5a2b 0%, #543419 100%);
      -webkit-background-clip:text; background-clip:text; color:transparent; text-shadow: 0 1px 0 rgba(255,255,255,0.5);
      font-size: clamp(16px, 4vw, 18px); }
    .hud .score{ justify-self:center; font-size: clamp(18px, 5vw, 22px); }
    .hud .high{ justify-self:end; font-size: clamp(14px, 4vw, 18px); }

    .board-shell{ position:relative; width:calc(var(--square-size) * var(--board-cols));
      height:calc(var(--square-size) * var(--board-rows)); max-width:95vw; max-height:95vh;
      border-radius:12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15), inset 0 0 0 4px rgba(107,74,48,0.25);
      background: radial-gradient(120% 120% at 50% 40%, #f6efe5 0%, #e9dcc9 30%, #d7c2a6 60%, #c4a782 100%); overflow:hidden; }
    .board{ position:absolute; inset:10px; display:grid;
      grid-template-columns: repeat(var(--board-cols), 1fr); grid-template-rows: repeat(var(--board-rows), 1fr);
      width:calc(100% - 20px); height:calc(100% - 20px); border-radius:10px; box-shadow: inset 0 6px 12px rgba(0,0,0,0.15); }

    .sq{ position:relative; display:flex; align-items:center; justify-content:center; user-select:none;
      transition: transform 120ms ease; font-size: calc(var(--square-size) * 0.6); line-height:1; }
    .sq:active{ transform: scale(0.98); }
    .light{ background: linear-gradient(180deg, #f0ddb9 0%, #e7cfa3 100%); }
    .dark{  background: linear-gradient(180deg, #c79159 0%, #b17a45 100%); }
    .sq::before{ content:""; position:absolute; inset:6%; border-radius:8px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.08); }

    .piece{ position:relative; z-index:2; filter: drop-shadow(0 1px 0 rgba(255,255,255,0.4)); }
    .white{ color:#fffef6; text-shadow: 0 2px 0 rgba(0,0,0,0.2); }
    .black{ color:#2f2a28; text-shadow: 0 2px 0 rgba(255,255,255,0.2); }

    .highlight::after{ content:""; position:absolute; inset:14%; border-radius:50%;
      background:radial-gradient(circle at 50% 50%, var(--hl) 0%, rgba(247,216,107,0.0) 70%);
      box-shadow: 0 0 0 3px rgba(247,216,107,0.8) inset; z-index:1; animation: pulse 900ms ease-in-out infinite; }
    @keyframes pulse{ 0%{ transform:scale(0.95); opacity:0.85; } 50%{ transform:scale(1.02); opacity:0.95; } 100%{ transform:scale(0.95); opacity:0.85; } }

    .advance{ animation: slideDown 420ms ease-in; }
    @keyframes slideDown{ 0%{ transform: translateY(0); } 90%{ transform: translateY(100%); } 100%{ transform: translateY(0); } }

    .controls{ width:calc(var(--square-size) * var(--board-cols)); max-width:95vw;
      display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:8px; }
    button{ padding:10px 14px; border-radius:10px; border:none; font-weight:700;
      background: linear-gradient(180deg, #f8e9c8 0%, #e8d4a8 100%); color:#3a2a18; box-shadow: 0 3px 0 #b3925e, 0 6px 12px rgba(0,0,0,0.12); }
    button:active{ transform: translateY(1px); box-shadow: 0 2px 0 #b3925e, 0 3px 8px rgba(0,0,0,0.15); }

    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.35); z-index:50; }
    .modal.show{ display:flex; }
    .card{ background:#fffdf6; color:var(--text); border-radius:14px; padding:18px; width:min(420px, 92vw);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25); text-align:center; }
    .card h2{ margin:0 0 6px; }
    .small{ opacity:0.8; font-size:14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="title">ChessRun</div>
      <div id="score" class="score">0</div>
      <div id="high" class="high">Best: 0</div>
    </div>

    <div class="board-shell">
      <div id="board" class="board" aria-label="ChessRun board"></div>
    </div>

    <div class="controls">
      <button id="restartBtn" type="button">Restart</button>
      <div class="small">Tap your piece to show moves, then tap a highlighted square.</div>
    </div>
  </div>

  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="card">
      <h2 id="modalTitle">Game Over</h2>
      <p id="modalText">Score: 0</p>
      <button id="againBtn" type="button">Play Again</button>
    </div>
  </div>

  <script>
    const BOARD_ROWS = 11;
    const BOARD_COLS = 8;
    const TOP_ROW = BOARD_ROWS - 1;
    const WHITE = "W", BLACK = "B";

    const PROGRESSION = [
      {score: 0,   type: "P"},
      {score: 20,  type: "K"},
      {score: 50,  type: "N"},
      {score: 100, type: "B"},
      {score: 200, type: "R"},
      {score: 300, type: "Q"}
    ];
    const WHITE_SYM = { P:"♙", K:"♔", N:"♘", B:"♗", R:"♖", Q:"♕" };
    const BLACK_SYM = { p:"♟", k:"♚", n:"♞", b:"♝", r:"♜", q:"♛" };

    let board = createEmptyBoard();
    let player = { row: 0, col: 0, type: "P" };
    let score = 0;
    let high = 0;
    let highlighted = new Set();
    let gameOver = false;

    const $board = document.getElementById("board");
    const $score = document.getElementById("score");
    const $high  = document.getElementById("high");
    const $modal = document.getElementById("modal");
    const $modalText = document.getElementById("modalText");

    init();
    function init(){
      high = parseInt(localStorage.getItem("chessrun-highscore") || "0", 10);
      updateHigh();
      resetBoardForNewGame();
      renderBoard();
      document.getElementById("restartBtn").addEventListener("click", restart);
      document.getElementById("againBtn").addEventListener("click", restart);
      $board.addEventListener("click", onBoardClick);
    }
    function restart(){
      hideModal();
      score = 0;
      player.type = "P";
      highlighted.clear();
      gameOver = false;
      resetBoardForNewGame();
      renderBoard();
      updateScore();
    }

    function createEmptyBoard(){
      return Array.from({length: BOARD_ROWS}, () => Array.from({length: BOARD_COLS}, () => null));
    }
    function cloneBoard(src){
      return src.map(row => row.map(cell => cell ? { color: cell.color, type: cell.type } : null));
    }
    function placePiece(r, c, piece){ board[r][c] = piece ? { color: piece.color, type: piece.type } : null; }
    function inBounds(r, c){ return r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS; }
    function keyOf(r, c){ return r + "," + c; }
    function isBlackAt(r,c){ const p = board[r][c]; return p && p.color === BLACK; }
    function isEmpty(r,c){ return inBounds(r,c) && !board[r][c]; }

    function resetBoardForNewGame(){
      board = createEmptyBoard();
      player.col = Math.floor(Math.random() * BOARD_COLS);
      player.row = 0;
      placePiece(player.row, player.col, { color: WHITE, type: player.type });
      generateSegmentWithTruthPathAndChoices();
      updateScore();
    }

    function generateSegmentWithTruthPathAndChoices(){
      randomlyPlaceOpposition(randInt(6,10));
      let attempts = 0;
      while (attempts < 25){
        const res = bfsPawnSafePath(board);
        if (res && res.path && res.path.length){
          const protectedSquares = new Set(res.path.map(s => keyOf(s.r, s.c)));
          injectBranchChoices(res.path, protectedSquares);
          ensureProtectedSquaresSafe(protectedSquares);
          enforceOppositionCountRange(6, 10, protectedSquares);
          const res2 = bfsPawnSafePath(board);
          if (res2 && res2.path && res2.path.length){
            guardSquareFromAttack(player.row, player.col);
            return;
          } else {
            repairEarlyRows(protectedSquares);
            enforceOppositionCountRange(6, 10, protectedSquares);
          }
        } else {
          repairEarlyRows(new Set());
        }
        attempts++;
      }
      for (let r=1;r<=3;r++){ board[r][player.col] = null; guardSquareFromAttack(r, player.col); }
      enforceOppositionCountRange(6, 10, new Set());
    }

    function randomlyPlaceOpposition(target){
      let placed = 0; const candidates = [];
      for (let r=1;r<=TOP_ROW;r++){ for (let c=0;c<BOARD_COLS;c++) candidates.push({r,c}); }
      shuffle(candidates);
      while (placed < target && candidates.length){
        const {r,c} = candidates.pop(); if (board[r][c]) continue;
        const type = randomChoice(["p","n","b","r","q","k","n","b","r"]);
        board[r][c] = { color: BLACK, type }; placed++;
      }
    }

    function injectBranchChoices(path, protectedSquares){
      const candidates = path.filter(s => s.r >= 1 && s.r <= 6); shuffle(candidates);
      let added = 0; const targetChoices = randInt(1,3);
      for (const step of candidates){ if (added >= targetChoices) break;
        const i = path.findIndex(s => s.r === step.r && s.c === step.c); if (i <= 0) continue;
        const prev = path[i-1]; const r = step.r, c = step.c; const isForward = (c === prev.c);
        if (isForward){
          for (const dc of shuffleCopy([-1,+1])){ const altC = c + dc; if (!inBounds(r, altC)) continue;
            if (!board[r][altC]) board[r][altC] = { color: BLACK, type: randomChoice(["n","r","b"]) };
            pruneAttackersForCaptureLanding(prev.r, prev.c, r, altC);
            if (landingSafeAfterSimulatedCapture(prev.r, prev.c, r, altC)){
              protectedSquares.add(keyOf(r, altC)); ensureOneFollowUpFrom(r, altC, protectedSquares); added++; break;
            } else { board[r][altC] = null; }
          }
        } else {
          const altC = prev.c; board[r][altC] = null; guardSquareFromAttack(r, altC);
          protectedSquares.add(keyOf(r, altC)); ensureOneFollowUpFrom(r, altC, protectedSquares); added++;
        }
      }
    }

    function ensureOneFollowUpFrom(r, c, protectedSquares){
      const nr = r + 1; if (nr > TOP_ROW) return;
      if (isEmpty(nr, c)){ guardSquareFromAttack(nr, c); protectedSquares.add(keyOf(nr, c)); return; }
      for (const dc of shuffleCopy([-1,+1])){ const nc = c + dc; if (!inBounds(nr, nc)) continue;
        if (!board[nr][nc]) board[nr][nc] = { color: BLACK, type: randomChoice(["n","r","b"]) };
        pruneAttackersForCaptureLanding(r, c, nr, nc);
        if (landingSafeAfterSimulatedCapture(r, c, nr, nc)){ protectedSquares.add(keyOf(nr, nc)); return; } else { board[nr][nc] = null; }
      }
      board[nr][c] = null; guardSquareFromAttack(nr, c); protectedSquares.add(keyOf(nr, c));
    }

    function repairEarlyRows(protectedSquares){
      const c = player.col;
      for (let r=1; r<=3; r++){
        const forwardOk = isEmpty(r, c) && landingSafeAfterSimulatedMove(r-1, c, r, c);
        const leftOk = (c-1>=0) && isBlackAt(r, c-1) && landingSafeAfterSimulatedCapture(r-1, c, r, c-1);
        const rightOk= (c+1<BOARD_COLS) && isBlackAt(r, c+1) && landingSafeAfterSimulatedCapture(r-1, c, r, c+1);
        if (forwardOk || leftOk || rightOk) continue;
        for (const dc of shuffleCopy([-1,+1])){ const nc = c + dc; if (!inBounds(r, nc)) continue;
          board[r][nc] = { color: BLACK, type: randomChoice(["n","r","b"]) };
          pruneAttackersForCaptureLanding(r-1, c, r, nc);
          if (landingSafeAfterSimulatedCapture(r-1, c, r, nc)){ protectedSquares.add(keyOf(r, nc)); ensureOneFollowUpFrom(r, nc, protectedSquares); return; }
          else { board[r][nc] = null; }
        }
        board[r][c] = null; guardSquareFromAttack(r, c); protectedSquares.add(keyOf(r, c)); return;
      }
    }

    function enforceOppositionCountRange(min, max, forbidden){
      let count = countBlackPieces();
      if (count < min){ const need = min - count; const extras = collectOppCandidates(forbidden, "far"); placeOppFromCandidates(extras, need, forbidden); }
      while ((count = countBlackPieces()) > max){
        const list = []; for (let r=0;r<BOARD_ROWS;r++){ for (let c=0;c<BOARD_COLS;c++){
          const p = board[r][c]; if (p && p.color === BLACK && !forbidden.has(keyOf(r,c))){ list.push({r,c, d: Math.abs(c - player.col) + Math.abs(r - 0)}); }
        }} if (!list.length) break; list.sort((a,b)=>b.d - a.d); const rem = list[0]; board[rem.r][rem.c] = null;
      }
    }
    function collectOppCandidates(forbidden, bias){
      const cand = []; for (let r=1;r<=TOP_ROW;r++){ for (let c=0;c<BOARD_COLS;c++){
        if (board[r][c]) continue; const k = keyOf(r,c); if (forbidden.has(k)) continue;
        const nearLane = Math.abs(c - player.col) <= 2; if ((bias === "near" && nearLane) || (bias === "far" && !nearLane)) cand.push({r,c,bias});
      }} shuffle(cand); return cand;
    }
    function placeOppFromCandidates(candidates, need, forbidden){
      let placed = 0; for (const cand of candidates){ if (placed >= need) break; if (board[cand.r][cand.c]) continue;
        const type = chooseOppType(cand.bias); board[cand.r][cand.c] = { color: BLACK, type };
        if (attacksAnyProtected(cand.r, cand.c, type, forbidden)){ board[cand.r][cand.c] = null; continue; } placed++; }
      return placed;
    }
    function chooseOppType(bias){ return (bias === "near") ? randomChoice(["n","b","r","p"]) : randomChoice(["b","r","q","n","p","k"]); }

    function bfsPawnSafePath(b){
      const start = { r: player.row, c: player.col, firstDone: false, b: cloneBoard(b) };
      const queue = [start]; const seen = new Set([stateKey(start)]); const parent = new Map(); const stateMap = new Map([[stateKey(start), start]]);
      while (queue.length){ const s = queue.shift(); if (s.r === TOP_ROW){ return reconstructPath(s, parent, stateMap); }
        const moves = getPawnMovesOnBoard(s.b, s.r, s.c, s.firstDone);
        for (const mv of moves){ const next = simulatePawnMoveOnBoard(s, mv); if (!next) continue; const k = stateKey(next); if (seen.has(k)) continue;
          seen.add(k); parent.set(k, stateKey(s)); stateMap.set(k, next); queue.push(next); }
      } return null;
    }
    function reconstructPath(endState, parent, stateMap){ const path = []; let k = stateKey(endState);
      while (k){ const st = stateMap.get(k); path.push({ r: st.r, c: st.c }); k = parent.get(k); } path.reverse(); return { path }; }
    function stateKey(st){ return st.r + "|" + st.c + "|" + (st.firstDone?1:0) + "|" + hashBoard(st.b); }
    function hashBoard(b){ let s = ""; for (let r=0;r<BOARD_ROWS;r++){ for (let c=0;c<BOARD_COLS;c++){ const p = b[r][c]; s += (p ? (p.color === BLACK ? p.type : p.type.toLowerCase()) : "."); }} return s; }
    function getPawnMovesOnBoard(b, r, c, firstDone){
      const out = []; const add = (rr,cc)=>{ if (!inBounds(rr,cc)) return; const d=b[rr][cc]; if (!d || d.color===BLACK) out.push({toRow:rr,toCol:cc}); };
      const f1 = r + 1, f2 = r + 2; if (inBounds(f1,c) && !b[f1][c]) add(f1,c);
      if (!firstDone && r === 0 && inBounds(f2,c) && !b[f1][c] && !b[f2][c]) add(f2,c);
      if (inBounds(f1,c-1) && b[f1][c-1] && b[f1][c-1].color===BLACK) add(f1,c-1);
      if (inBounds(f1,c+1) && b[f1][c+1] && b[f1][c+1].color===BLACK) add(f1,c+1);
      return out;
    }
    function simulatePawnMoveOnBoard(state, mv){
      const nb = cloneBoard(state.b); nb[state.r][state.c] = null; nb[mv.toRow][mv.toCol] = { color: WHITE, type: "P" };
      if (isSquareAttackedByBlackOnBoard(nb, mv.toRow, mv.toCol)) return null; const nextFirstDone = state.firstDone || (state.r === 0);
      return { r: mv.toRow, c: mv.toCol, firstDone: nextFirstDone, b: nb };
    }
    function isSquareAttackedByBlackOnBoard(b, r, c){
      for (let rr=0; rr<BOARD_ROWS; rr++){ for (let cc=0; cc<BOARD_COLS; cc++){ const p = b[rr][cc]; if (!p || p.color !== BLACK) continue;
        if (blackAttacksSquareOnBoard(p.type, rr, cc, r, c, b)) return true; }} return false;
    }
    function blackAttacksSquareOnBoard(type, br, bc, tr, tc, b){
      const dr = tr - br, dc = tc - bc;
      if (type === "p"){ return (tr === br - 1) && (tc === bc - 1 || tc === bc + 1); }
      if (type === "k"){ return Math.max(Math.abs(dr), Math.abs(dc)) === 1; }
      if (type === "n"){ return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2); }
      if (type === "b" || type === "r" || type === "q"){
        const dirs = []; if (type !== "r") dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if (type !== "b") dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [drr,dcc] of dirs){ let rr=br+drr, cc=bc+dcc;
          while (inBounds(rr, cc)){ if (rr === tr && cc === tc) return true; const occ = b[rr][cc]; if (occ) break; rr += drr; cc += dcc; }
        } return false;
      }
      return false;
    }

    function landingSafeAfterSimulatedMove(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC], prevTo = board[toR][toC];
      board[fromR][fromC] = null; board[toR][toC] = { color: WHITE, type: player.type };
      const attacked = isSquareAttackedByBlack(toR, toC);
      board[fromR][fromC] = prevFrom || null; board[toR][toC] = prevTo || null;
      return !attacked;
    }
    function landingSafeAfterSimulatedCapture(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC], prevTo = board[toR][toC];
      board[fromR][fromC] = null; board[toR][toC] = { color: WHITE, type: player.type };
      const attacked = isSquareAttackedByBlack(toR, toC);
      board[fromR][fromC] = prevFrom || null; board[toR][toC] = prevTo || null;
      return !attacked;
    }
    function pruneAttackersForCaptureLanding(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC], prevTo = board[toR][toC];
      board[fromR][fromC] = null; board[toR][toC] = { color: WHITE, type: player.type };
      let guard = 0; while (isSquareAttackedByBlack(toR, toC) && guard < 300){
        const atks = attackersOfSquare(toR, toC); if (!atks.length) break;
        atks.sort((a,b)=>((a.row-toR)**2+(a.col-toC)**2)-((b.row-toR)**2+(b.col-toC)**2));
        const kill = atks[0]; board[kill.row][kill.col] = null; guard++; }
      board[fromR][fromC] = prevFrom || null; board[toR][toC] = prevTo || null;
    }

    function isSquareAttackedByBlack(r, c){
      for (let rr = 0; rr < BOARD_ROWS; rr++){ for (let cc = 0; cc < BOARD_COLS; cc++){
        const p = board[rr][cc]; if (!p || p.color !== BLACK) continue;
        if (blackAttacksSquare(p.type, rr, cc, r, c)) return true; }} return false;
    }
    function attackersOfSquare(r, c){
      const list = []; for (let rr=0; rr<BOARD_ROWS; rr++){ for (let cc=0; cc<BOARD_COLS; cc++){
        const p = board[rr][cc]; if (!p || p.color !== BLACK) continue;
        if (blackAttacksSquare(p.type, rr, cc, r, c)) list.push({row: rr, col: cc, type: p.type}); }} return list;
    }
    function blackAttacksSquare(type, br, bc, tr, tc){
      const dr = tr - br, dc = tc - bc;
      if (type === "p"){ return (tr === br - 1) && (tc === bc - 1 || tc === bc + 1); }
      if (type === "k"){ return Math.max(Math.abs(dr), Math.abs(dc)) === 1; }
      if (type === "n"){ return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2); }
      if (type === "b" || type === "r" || type === "q"){
        const dirs = []; if (type !== "r") dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if (type !== "b") dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [drr,dcc] of dirs){ let rr = br + drr, cc = bc + dcc;
          while (inBounds(rr, cc)){ if (rr === tr && cc === tc) return true; const occ = board[rr][cc]; if (occ) break; rr += drr; cc += dcc; }
        } return false;
      }
      return false;
    }
    function guardSquareFromAttack(r, c){
      let guard = 0; while (isSquareAttackedByBlack(r, c) && guard < 300){
        const atks = attackersOfSquare(r, c); if (!atks.length) break;
        atks.sort((a,b)=>((a.row-r)**2+(a.col-c)**2)-((b.row-r)**2+(b.col-c)**2));
        const kill = atks[0]; board[kill.row][kill.col] = null; guard++; }
    }
    function attacksAnyProtected(br, bc, type, protectedSquares){
      for (const k of protectedSquares){ const [r,c] = k.split(",").map(Number);
        if (blackAttacksSquare(type, br, bc, r, c)) return true; }
      return false;
    }
    function ensureProtectedSquaresSafe(protectedSquares){ for (const k of protectedSquares){ const [r,c] = k.split(",").map(Number); guardSquareFromAttack(r,c); } }

    function onBoardClick(e){ if (gameOver) return; const target = e.target.closest(".sq"); if (!target) return;
      const r = parseInt(target.dataset.row, 10), c = parseInt(target.dataset.col, 10);
      if (r === player.row && c === player.col){ const moves = getLegalMoves(player.type, player.row, player.col);
        highlighted = new Set(moves.map(m => keyOf(m.toRow, m.toCol))); renderBoard(); return; }
      const key = keyOf(r,c); if (highlighted.has(key)){ highlighted.clear(); performMove(r,c); renderBoard(); } else { highlighted.clear(); renderBoard(); }
    }
    function performMove(toRow, toCol){ if (gameOver) return; const forwardGain = Math.max(0, toRow - player.row);
      board[player.row][player.col] = null; player.row = toRow; player.col = toCol; placePiece(player.row, player.col, { color: WHITE, type: player.type });
      if (forwardGain > 0){ score += forwardGain; updateScore(); applyProgression(); }
      if (isSquareAttackedByBlack(player.row, player.col)){ endGame(); return; }
      if (player.row === TOP_ROW){ advanceAndRegenerate(); }
    }
    function updateScore(){ $score.textContent = String(score); if (score > high){ high = score; localStorage.setItem("chessrun-highscore", String(high)); updateHigh(); } }
    function updateHigh(){ $high.textContent = "Best: " + String(high); }
    function applyProgression(){ let newType = player.type; for (let i = PROGRESSION.length - 1; i >= 0; i--){ if (score >= PROGRESSION[i].score){ newType = PROGRESSION[i].type; break; } }
      if (newType !== player.type){ player.type = newType; placePiece(player.row, player.col, { color: WHITE, type: player.type }); } }
    function advanceAndRegenerate(){ $board.classList.add("advance"); const onAnimEnd = () => {
        $board.removeEventListener("animationend", onAnimEnd); $board.classList.remove("advance");
        const newBoard = createEmptyBoard(); for (let c = 0; c < BOARD_COLS; c++){ newBoard[0][c] = board[player.row][c] ? { ...board[player.row][c] } : null; }
        board = newBoard; player.row = 0; generateSegmentWithTruthPathAndChoices(); renderBoard(); };
      $board.addEventListener("animationend", onAnimEnd); }

    function getLegalMoves(type, r, c){ const moves = []; const add = (rr, cc) => { if (!inBounds(rr, cc)) return; const d = board[rr][cc]; if (!d || d.color === BLACK) moves.push({ toRow: rr, toCol: cc }); };
      if (type === "P"){ const f1 = r + 1, f2 = r + 2; if (inBounds(f1, c) && !board[f1][c]) add(f1, c);
        if (r === 0 && inBounds(f2, c) && !board[f1][c] && !board[f2][c]) add(f2, c);
        if (inBounds(f1, c-1) && isBlackAt(f1, c-1)) add(f1, c-1);
        if (inBounds(f1, c+1) && isBlackAt(f1, c+1)) add(f1, c+1);
      } else if (type === "K"){ for (let dr = -1; dr <= 1; dr++){ for (let dc = -1; dc <= 1; dc++){ if (dr||dc) add(r+dr,c+dc); } }
      } else if (type === "N"){ [[ 2, 1],[ 2,-1],[-2, 1],[-2,-1],[ 1, 2],[ 1,-2],[-1, 2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
      } else if (type === "B"){ ray(r,c,[[1,1],[1,-1],[-1,1],[-1,-1]],moves);
      } else if (type === "R"){ ray(r,c,[[1,0],[-1,0],[0,1],[0,-1]],moves);
      } else if (type === "Q"){ ray(r,c,[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],moves); }
      return moves; }
    function ray(r,c,dirs,out){ for (const [dr,dc] of dirs){ let rr=r+dr, cc=c+dc;
        while (inBounds(rr,cc)){ const d = board[rr][cc]; if (!d) out.push({toRow:rr,toCol:cc}); else { if (d.color===BLACK) out.push({toRow:rr,toCol:cc}); break; } rr+=dr; cc+=dc; }
      } }

    function renderBoard(){ const frag = document.createDocumentFragment(); $board.innerHTML = "";
      for (let vRow = BOARD_ROWS - 1; vRow >= 0; vRow--){ for (let c = 0; c < BOARD_COLS; c++){
          const sq = document.createElement("div"); sq.className = "sq " + (((vRow + c) % 2 === 0) ? "light" : "dark");
          sq.dataset.row = String(vRow); sq.dataset.col = String(c);
          const p = board[vRow][c]; if (p){ const span = document.createElement("span"); span.className = "piece " + (p.color === WHITE ? "white" : "black");
            span.textContent = p.color === WHITE ? WHITE_SYM[p.type] : BLACK_SYM[p.type]; sq.appendChild(span); }
          if (highlighted.has(keyOf(vRow,c))) sq.classList.add("highlight"); frag.appendChild(sq);
      }} $board.appendChild(frag); }

    function endGame(){ gameOver = true; showModal("Game Over", "Score: " + String(score)); }
    function showModal(title, text){ document.getElementById("modalTitle").textContent = title; $modalText.textContent = text; $modal.classList.add("show"); }
    function hideModal(){ $modal.classList.remove("show"); }

    function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
    function randomChoice(bag){ return bag[Math.floor(Math.random() * bag.length)]; }
    function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    function shuffleCopy(a){ const b=a.slice(); shuffle(b); return b; }
    function countBlackPieces(){ let n = 0; for (let r=0;r<BOARD_ROWS;r++){ for (let c=0;c<BOARD_COLS;c++){ const p = board[r][c]; if (p && p.color === BLACK) n++; } } return n; }
  </script>
</body>
</html>