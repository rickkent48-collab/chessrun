<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ChessRun</title>
  <!-- Boogaloo font for all text -->
  <link href="https://fonts.googleapis.com/css2?family=Boogaloo&display=swap" rel="stylesheet">
  <style>
    :root{
      --gold: #EFBF04; /* bolder, unified gold used everywhere */
      --black: #020102; /* unified black across the app */
      --board-cols: 8;
      --board-rows: 11;
      --square-size: calc(100vw / var(--board-cols));
      --light: #ffffff;  /* board light squares: white */
      --dark:  var(--black);  /* board dark squares: black */
      --text:  var(--gold);
      --danger: #D32F2F; /* killer highlight is RED now */
      
      /* Chess Run theme piece colors */
      --user-piece: var(--gold); /* user piece gold */
      --opp-piece: #006CFF; /* Chess Run opposition standard color */

      --above-gap: 10px;
      --below-gap: calc(var(--above-gap) * 2);

      /* Slow, smooth scroll duration for advancing */
      --advance-duration: 2400ms;
    }

    html,body{
      margin:0; padding:0; background:var(--dark); color:var(--text);
      font-family: "Boogaloo", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      touch-action: none;
    }

    .wrap{
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
      min-height:100vh; gap:var(--above-gap); padding:10px 0 24px;
      background:var(--dark);
    }

    /* HUD: captures | score | high */
    .hud{
      width:100vw;
      display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;
      padding:0 8px; box-sizing:border-box; gap:0;
      color:var(--text);
    }
    .captures, .score, .high{
      font-weight:700; letter-spacing:0.3px;
      font-size: clamp(18px, 5vw, 22px);
      line-height:1;
    }
    .captures{ justify-self:start; text-align:left; color: var(--gold); }
    .score{    justify-self:center; text-align:center; font-size: clamp(54px, 15vw, 66px); }
    .high{     justify-self:end; text-align:right; color: var(--gold); }

    .board-shell{
      position:relative;
      width:100vw; height:calc(var(--square-size) * var(--board-rows));
      max-width:100vw; max-height:95vh;
      border-radius:0; box-shadow:none; background:var(--dark);
      overflow:hidden;
    }
    .board{
      position:absolute; inset:0;
      display:grid; grid-template-columns: repeat(var(--board-cols), 1fr);
      grid-template-rows: repeat(var(--board-rows), 1fr);
      width:100%; height:100%;
    }

    /* Single-strip scroller */
    .strip-scroller{
      position:absolute; left:0; width:100%;
      transform: translateY(0);
      pointer-events:none;
      will-change: transform;
      z-index:5;
    }
    .strip-scroller.transition{
      transition: transform var(--advance-duration) cubic-bezier(0.22, 0.61, 0.2, 1);
    }
    .strip-part{
      position:relative; width:100%;
    }
    .strip-grid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(var(--board-cols), 1fr);
      width:100%; height:100%;
    }

    .sq{
      position:relative;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
      transition: transform 120ms ease;
      font-size: calc(var(--square-size) * 0.6);
      line-height:1;
      font-family: "Boogaloo", system-ui;
    }
    .sq:active{ transform: scale(0.98); }

    .light{ background: var(--light); }
    .dark{  background: var(--dark); }

    /* Piece visuals: use CSS variables for piece colors */
    .piece{ position:relative; z-index:2; font-family: "Boogaloo", system-ui; }
    /* Ensure piece colors use variables globally */
    .piece.white{ color: var(--user-piece) !important; }
    .piece.black{ color: var(--opp-piece) !important; }
    .piece svg{ width:calc(var(--square-size) * 0.6); height:calc(var(--square-size) * 0.6); display:block; margin:auto; }

    /* Under-board controls */
    .controls{
      width:100vw;
      display:flex; justify-content:space-between; align-items:center;
      gap:20px; padding:0 18px; box-sizing:border-box;
      margin-top: 0;
      font-family: "Boogaloo", system-ui;
    }
    .controls button{
      background: transparent; border:none; padding:10px 0;
      color: #ffffff; font-weight:700; font-size: clamp(18px, 5vw, 22px);
      cursor:pointer; font-family: "Boogaloo", system-ui;
    }
    .controls button:active{ opacity:0.8; }

    /* Modal */
    /* Modal overlay: keep screen visible; do not darken; allow buttons below to work */
    .modal{ position:fixed; inset:0; display:none; z-index:60; background: transparent; pointer-events:none; }
    .modal.show{ display:block; }

    /* Game Over card over the board */
    .go-card{
      position: fixed; /* positioned via JS relative to board */
      background: var(--black) !important; /* black */
      border-radius: 18px;
      color: var(--gold); /* gold text */
      box-sizing: border-box;
      /* gold accent line all the way around */
      border: 4px solid var(--gold);
      padding: 16px 20px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 10px; /* even spacing between items */
      pointer-events: none; /* tapping does nothing */
      font-family: "Boogaloo", system-ui;
    }
    .go-item-label{ font-size: clamp(18px, 5vw, 22px); font-weight: 800; }
    .go-item-value{ font-size: clamp(18px, 5vw, 22px); font-weight: 800; }
    /* White text utility for specific GO items */
    .go-white{ color:#FFFFFF; }
    /* Ensure confirm title uses the exact Stats white (#FFFFFF) */
    .confirm-title{ color:#FFFFFF !important; }
    /* Blank line spacing under High Score number */
    .go-item-blank{ font-size: clamp(18px, 5vw, 22px); line-height:1; }

    /* Menu overlay: big diagonal squares, no inner lines (inherits black/white) */
    .menu{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:70; background: var(--black); border: var(--accent-w) solid var(--gold); border-radius: var(--sheet-radius); box-sizing: border-box; }
    .menu.show{ display:flex; align-items:flex-start; justify-content:center; }
    .menu::before{
      content:"";
      position:absolute; inset:0;
      background: var(--black) !important;
      border-radius: inherit;
    }
    /* While menu is open, ensure page corners are also black (body for viewport corners, wrap for content area) */
    .menu-open, .menu-open .wrap{ background: var(--black) !important; }
    .menu-content{
      position:relative; z-index:1;
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
      gap:24px; text-align:center; color:#000000; font-family: "Boogaloo", system-ui;
      padding-top: 0;
    }
    .menu-title{
      font-size: clamp(32px, 10vw, 64px);
      font-weight: 900;
      letter-spacing: 1px;
      text-shadow: 0 2px 0 rgba(0,0,0,0.05);
      font-family: "Boogaloo", system-ui;
      color: var(--gold);
    }
    .menu-logo{
      display:block;
      width: 70vw;            /* large, but leaves big horizontal gaps */
      max-height: 45vh;       /* most of the top half of screen */
      height: auto;
      object-fit: contain;
      margin-top: calc((100vw - 70vw) / 2);  /* top gap equals side gaps */
      margin-bottom: 2vh;
      margin-left: auto;
      margin-right: auto;
      pointer-events: none;   /* decorative */
    }
    .play-btn{
      position: relative;
      width: min(220px, 50vw);
      height: 48px;
      padding: 14px 28px; border-radius:14px; border:none; cursor:pointer;
      font-size: clamp(18px, 5vw, 22px); font-weight:800;
      color: #000000; font-family: "Boogaloo", system-ui;
      background: var(--gold);
      box-shadow: none;
    }
    .play-btn::after{
      content: "";
      position: absolute;
      inset: 6px;
      border: 2px solid #000000;
      border-radius: 10px;
      pointer-events: none;
    }
    .play-btn:active{ transform: translateY(1px); box-shadow: none; }

    /* Stats overlay - bottom sheet */
    :root{
      --accent-w: 4px;        /* gold line thickness */
      --accent-gap: 8px;      /* black edge spacing (equal to line offset) */
      --sheet-radius: 18px;
    }
    
    .stats{ position:fixed; inset:0; display:none; z-index:75; border: var(--accent-w) solid var(--gold); border-radius: var(--sheet-radius); box-sizing: border-box; }
    .stats.show{ display:block; }
    .stats-backdrop{ position:fixed; top:0; left:0; right:0; height:50vh; background: transparent; border-radius: var(--sheet-radius); }
    .stats-sheet{
      position:fixed; left:0; right:0; bottom:0; height:58vh; background: var(--black); color: var(--text);
      border-radius: var(--sheet-radius);
      border: var(--accent-w) solid var(--gold); /* full gold outline with rounded corners */
      box-sizing: border-box;
    }
    /* Remove inner border; keep content spacing */
    .stats-inner{
      position:absolute;
      top: var(--accent-gap); left: var(--accent-gap); right: var(--accent-gap); bottom: 0;
      border: none; /* no inner border now */
      border-top-left-radius: var(--sheet-radius); border-top-right-radius: var(--sheet-radius);
      padding: 12px 16px; /* inner padding so title doesn't overlap the top accent */
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
    }

    /* Typography and spacing: slightly larger than before, uniform rows */
    .stats-title{ font-size: clamp(16px, 4.5vw, 20px); font-weight:800; text-align:center; line-height: 1; }
    .stats-list{ width:100%; display:flex; flex-direction:column; gap:8px; }
    .stat-row{ display:flex; justify-content:space-between; font-size: clamp(16px, 4.5vw, 20px); line-height: 1; }
    /* Equal spacing above first stat and below last stat using symmetric spacers */
    .stats-spacer{ height: 2em; flex: 0 0 auto; }
    .stats-inner .stats-spacer:last-child{ display: none; }
    
    /* Blank line entries */
    .stat-blank{ height: 1em; font-size: clamp(16px, 4.5vw, 20px); line-height: 1; }
    
    /* Row color utilities */
    .stat-white{ color: #FFFFFF; }
    .stat-gold{  color: var(--gold); }

    /* Remove red glow and set selected visual with white background */
    #themes .play-btn{ color:#000000 !important; }
    #themes .play-btn.selected{
      background:#FFFFFF !important; /* replace gold with white when selected */
      color:#000000 !important;      /* explicit black text */
      box-shadow:none !important;    /* remove any previous glow */
    }

    /* Classic theme variables and scoped overrides */
    .theme-classic{
      /* Board colors */
      --light: #E6D0A8; /* light brown */
      --dark:  #7B5E3B; /* dark brown (not too dark) */
      /* Piece colors as variables to prevent flash during roll-down animation */
      --user-piece: #FFFFFF;     /* user white */
      --opp-piece:  var(--black);/* opponent black */
    }
    /* Above/below board backgrounds already use var(--dark), so they will match dark brown */

    /* Scores (captures | score | high) pure white in Classic */
    .theme-classic .captures,
    .theme-classic .score,
    .theme-classic .high{ color:#FFFFFF !important; }

    /* In-game under-board controls: Menu and Restart buttons as light brown */
    .theme-classic .controls button{ color:#E6D0A8 !important; }

    /* Classic theme board visuals (using variables prevents flash during roll-down) */
    .theme-classic .piece.white{ color: var(--user-piece) !important; }  /* user white */
    .theme-classic .piece.black{ color: var(--opp-piece) !important; }  /* opposition black (fixes blue pawns) */

    /* Place this AFTER the .piece.white/.piece.black variable-driven rules */
    .piece.danger,
    .piece.danger.white,
    .piece.danger.black{
      color: var(--danger) !important; /* force red for any highlighted killer piece */
    }

    /* Classic theme Game Over card: white text, dark brown background, black outline */
    .theme-classic .go-card{
      background: var(--dark) !important; /* dark brown */
      border-color: var(--black) !important; /* outline becomes canonical black */
      color: #FFFFFF !important; /* all gold text becomes white */
    }
    .theme-classic .go-white{ color:#FFFFFF !important; }

    /* In Classic theme, set High Score and Most Captures entries to light brown (Classic light square color) */
    .theme-classic .go-item-label.go-white,
    .theme-classic .go-item-value.go-white{
      color: var(--light) !important; /* Classic light brown */
    }

    /* Neon theme palette refinements */
    .theme-neon{
      --light: #00E5FF;   /* neon blue (light square) */
      --dark:  #8A00FF;   /* neon purple (dark square & background) */

      /* Neon yellow for scores and user piece */
      --user-piece: #FFF01F; /* user piece (matches neon yellow scores) */

      /* Opposition bold neon orange */
      --opp-piece:  #FF6A00;

      /* Killer highlight neon red */
      --danger: #FF1744;
    }

    /* Neon HUD scores use the same neon yellow */
    .theme-neon .captures,
    .theme-neon .score,
    .theme-neon .high{ color: var(--user-piece) !important; }

    /* Under-board controls text buttons neon blue in Neon */
    .theme-neon .controls button{ color: var(--light) !important; }

    /* Neon: remove all glow from squares */
    .theme-neon .sq.light{ box-shadow: none !important; }
    .theme-neon .sq.dark { box-shadow: none !important; }

    /* Ensure Neon user/opposition piece colors win and killer highlight overrides theme colors */
    .theme-neon .piece.white{ color: var(--user-piece) !important; }
    .theme-neon .piece.black{ color: var(--opp-piece) !important; }
    .theme-neon .piece.danger{ color: var(--danger) !important; }

    /* GO pop-up in Neon */
    .theme-neon .go-card{
      border-color: #FF6A00 !important; /* neon orange outline */
      background:   #00E5FF !important; /* neon blue background */
    }
    /* Default GO labels/values neon orange in Neon */
    .theme-neon .go-item-label,
    .theme-neon .go-item-value{ color:#FF6A00 !important; }
    /* High Score & Most Captures rows neon purple in Neon (marked by go-white) */
    .theme-neon .go-item-label.go-white,
    .theme-neon .go-item-value.go-white{ color:#8A00FF !important; }

    /* Ocean theme palette and scoped UI overrides */
    .theme-ocean{
      --light: #007FFF;  /* ocean light square */
      --dark:  #00008B;  /* ocean dark square & background */
      --user-piece: #FFFFFF; /* user piece white */
      --opp-piece:  #00F0FF; /* opposition pieces */
      /* Use existing danger red for killer highlight */
    }

    /* HUD scores white in Ocean */
    .theme-ocean .captures,
    .theme-ocean .score,
    .theme-ocean .high{ color:#FFFFFF !important; }

    /* Ocean GO pop-up styling */
    .theme-ocean .go-card{
      border-color: #FFFFFF !important; /* white outline */
      background:   #007FFF !important; /* ocean blue background */
    }
    /* Score & Captures rows: white labels and values */
    .theme-ocean .go-item-label,
    .theme-ocean .go-item-value{ color:#FFFFFF !important; }
    /* High Score & Most Captures rows specifically (marked go-white): dark navy */
    .theme-ocean .go-item-label.go-white,
    .theme-ocean .go-item-value.go-white{ color:#00008B !important; }

    /* Under-board controls text buttons ocean light blue */
    .theme-ocean .controls button{ color:#007FFF !important; }

    /* Ensure menu overlay corners remain pure black when Ocean is selected */
    .theme-ocean .menu{ background: var(--black) !important; }
    .theme-ocean .menu::before{ background: var(--black) !important; border-radius: inherit; }

    /* Confirmation overlay centered with interactive card that looks like Game Over card */
    .confirm-overlay{ position:fixed; inset:0; display:none; z-index:80; align-items:center; justify-content:center; }
    .confirm-overlay.show{ display:flex; }
    .confirm-backdrop{ position:absolute; inset:0; background: rgba(0, 0, 0, 0.5); }
    .confirm-card{
      background: var(--black); border-radius: 18px; color: var(--gold);
      border: 4px solid var(--gold); box-sizing: border-box;
      padding: 16px 20px; display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap: 10px; pointer-events:auto; font-family:"Boogaloo", system-ui;
    }

    /* Vintage theme: carved wood effect without changing base colors */
    .theme-classic .piece{ /* Vintage is implemented by the class .theme-classic */
      /* Embossed/engraved feel using neutral (black/white) shadows */
      text-shadow:
        0 -1px 0 rgba(255,255,255,0.25), /* subtle top highlight */
        0  1px 0 rgba(0,0,0,0.30),        /* faint inner carve line */
        0  2px 1px rgba(0,0,0,0.20);      /* soft depth under piece */
      filter: brightness(0.99) contrast(1.03);
    }

    /* Pawn SVG: add strokes and subtle drop-shadows to simulate carved edges */
    .theme-classic .piece svg{
      filter: drop-shadow(0 -1px 0 rgba(255,255,255,0.20)) drop-shadow(0 2px 1px rgba(0,0,0,0.18));
    }
    .theme-classic .piece svg circle,
    .theme-classic .piece svg path,
    .theme-classic .piece svg rect{
      stroke: rgba(0,0,0,0.25); /* neutral dark engrave stroke */
      stroke-width: 1.2;
      paint-order: stroke fill; /* stroke sits above fill */
    }

    /* Remove carved wood effects in Vintage theme only */
    .theme-classic .piece{ text-shadow: none !important; filter: none !important; }
    .theme-classic .piece svg{ filter: none !important; }
    .theme-classic .piece svg circle,
    .theme-classic .piece svg path,
    .theme-classic .piece svg rect{ stroke: none !important; stroke-width: 0 !important; }
  </style>
</head>
<body>
  <!-- Background music -->
  <audio id="bgMusic" loop style="display:none;">
    <source src="CS1.mp3" type="audio/mpeg">
  </audio>

  <div class="wrap">
    <div class="hud">
      <div id="captures" class="captures">0</div>
      <div id="score" class="score">0</div>
      <div id="high" class="high">0</div>
    </div>

    <div class="board-shell">
      <div id="board" class="board" aria-label="ChessRun board"></div>
    </div>

    <div class="controls">
      <button id="menuBtn" type="button">Menu</button>
      <button id="restartBtn" type="button">Restart</button>
    </div>
  </div>

  <!-- Menu overlay -->
  <div id="menu" class="menu" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
    <div class="menu-content">
      <img id="menuTitle" class="menu-logo" src="data:image/png;base64,PASTE BASE64 STRING HERE" alt="Chess Run logo" />
      <button id="playBtn" class="play-btn" type="button">Start</button>
      <button id="statsBtn" class="play-btn" type="button">Stats</button>
      <button id="themesBtn" class="play-btn" type="button">Themes</button>
      <button id="settingsBtn" class="play-btn" type="button">Settings</button>
    </div>
  </div>

  <div id="stats" class="stats" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
    <div id="statsBackdrop" class="stats-backdrop" aria-hidden="true"></div>
    <div id="statsSheet" class="stats-sheet">
      <div class="stats-inner">
        <div id="statsTitle" class="stats-title">Stats</div>
        <div class="stats-spacer"></div>
        <div class="stats-list">
          <div class="stat-row stat-white"><span>Total Games</span><span id="statTotalGames">0</span></div>
          <div class="stat-blank">&nbsp;</div>

          <div class="stat-row stat-gold"><span>High Score</span><span id="statHigh">0</span></div>
          <div class="stat-blank">&nbsp;</div>

          <div class="stat-row stat-white"><span>Total Score</span><span id="statTotalScore">0</span></div>
          <div class="stat-blank">&nbsp;</div>

          <div class="stat-row stat-gold"><span>Average Score</span><span id="statAvgScore">0</span></div>
          <div class="stat-blank">&nbsp;</div>

          <div class="stat-row stat-white"><span>Most Captures</span><span id="statMostTakes">0</span></div>
          <div class="stat-blank">&nbsp;</div>

          <div class="stat-row stat-gold"><span>Total Captures</span><span id="statTotalTakes">0</span></div>
          <div class="stat-blank">&nbsp;</div>

          <div class="stat-row stat-white"><span>Average Captures</span><span id="statAvgTakes">0</span></div>
          <div class="stat-blank">&nbsp;</div>
        </div>
        <div class="stats-spacer"></div>
      </div>
    </div>
  </div>

  <div id="settings" class="stats" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div id="settingsBackdrop" class="stats-backdrop" aria-hidden="true"></div>
    <div id="settingsSheet" class="stats-sheet">
      <div class="stats-inner">
        <div id="settingsTitle" class="stats-title">Settings</div>
        <div class="stats-spacer"></div>
        <div class="stats-list">
          <div class="stat-row" style="justify-content:center;">
            <button id="musicToggleBtn" class="play-btn" type="button" aria-pressed="true">Music Enabled</button>
          </div>
          <div class="stat-blank">&nbsp;</div>
          <div class="stat-row" style="justify-content:center;">
            <button id="resetStatsBtn" class="play-btn" type="button">Reset Stats</button>
          </div>
        </div>
        <div class="stats-spacer"></div>
      </div>
    </div>
  </div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div id="goCard" class="go-card" aria-hidden="true"></div>
  </div>

  <div id="resetStats" class="stats" role="dialog" aria-modal="true" aria-labelledby="resetStatsTitle">
    <div id="resetStatsBackdrop" class="stats-backdrop" aria-hidden="true"></div>
    <div id="resetStatsSheet" class="stats-sheet">
      <div class="stats-inner">
        <div id="resetStatsTitle" class="stats-title">Reset Stats</div>
        <div class="stats-spacer"></div>
        <div class="stats-list">
          <div class="stat-row stat-white" style="justify-content:center;">
            <span>Are you sure you want to reset all stats?</span>
          </div>
          <div class="stat-blank">&nbsp;</div>
          <div class="stat-row" style="justify-content:center;">
            <button id="confirmResetBtn" class="play-btn" type="button">Reset Stats</button>
          </div>
          <div class="stat-blank">&nbsp;</div>
          <div class="stat-row" style="justify-content:center;">
            <button id="cancelResetBtn" class="play-btn" type="button">Cancel</button>
          </div>
        </div>
        <div class="stats-spacer"></div>
      </div>
    </div>
  </div>

  <div id="themes" class="stats" role="dialog" aria-modal="true" aria-labelledby="themesTitle">
    <div id="themesBackdrop" class="stats-backdrop" aria-hidden="true"></div>
    <div id="themesSheet" class="stats-sheet">
      <div class="stats-inner">
        <div id="themesTitle" class="stats-title">Themes</div>
        <div class="stats-spacer"></div>
        <div class="stats-list">
          <div class="stat-row" style="justify-content:center;">
            <button id="themeChessRunBtn" class="play-btn" type="button">Classic</button>
          </div>
          <div class="stat-blank">&nbsp;</div>
          <div class="stat-row" style="justify-content:center;">
            <button id="themeClassicBtn" class="play-btn" type="button">Vintage</button>
          </div>
          <div class="stat-blank">&nbsp;</div>
          <div class="stat-row" style="justify-content:center;">
            <button id="themeOceanBtn" class="play-btn" type="button">Ocean</button>
          </div>
          <div class="stat-blank">&nbsp;</div>
          <div class="stat-row" style="justify-content:center;">
            <button id="themeNeonBtn" class="play-btn" type="button">Neon</button>
          </div>
        </div>
        <div class="stats-spacer"></div>
      </div>
    </div>
  </div>

  <script>
  // Robust gapless background music manager with debounced gesture start and fade envelopes
  let audioCtx = null;
  let bgmArrayBuffer = null;      // Prefetched raw audio bytes
  let musicBuffer = null;         // Decoded AudioBuffer
  let musicSource = null;         // Current BufferSource
  let gainNode = null;            // Gain for fade in/out
  let musicEnabled = localStorage.getItem('chessrun-music-enabled') !== 'false'; // Controlled by Settings toggle
  let musicStarting = false;      // Debounce flag
  let gestureHandled = false;     // Prevent double start from pointerdown + click
  let musicStartupComplete = false; // Tracks successful startup; can be used for diagnostics or future enhancements

  // If legacy <audio id="bgm"> exists, ensure it never plays alongside Web Audio
  (function disableLegacyBgm(){
    const legacy = document.getElementById('bgm');
    if (legacy){ try{ legacy.pause(); legacy.muted = true; }catch(e){} }
  })();

  // Prefetch the mp3 bytes as early as possible (no autoplay implications)
  (function prefetchBgm(){
    try {
      fetch('CS1.mp3', { cache: 'force-cache' })
        .then(r => r.arrayBuffer())
        .then(arr => { bgmArrayBuffer = arr; })
        .catch(()=>{});
    } catch(e){}
  })();

  async function ensureAudioContext(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended'){
      try { await audioCtx.resume(); } catch(e){}
    }
    return audioCtx;
  }

  async function ensureDecodedBuffer(){
    await ensureAudioContext();
    if (musicBuffer) return musicBuffer;
    // If prefetch didn't finish yet, fetch now
    try {
      if (!bgmArrayBuffer){
        const resp = await fetch('CS1.mp3', { cache: 'force-cache' });
        bgmArrayBuffer = await resp.arrayBuffer();
      }
      musicBuffer = await audioCtx.decodeAudioData(bgmArrayBuffer); // decode prefetched buffer
    } catch(e){ /* silently fail; will retry on next gesture */ }
    return musicBuffer;
  }

  function disconnectSource(){
    if (musicSource){
      try { musicSource.disconnect(); } catch(e){}
      musicSource = null;
    }
    if (gainNode){
      try { gainNode.disconnect(); } catch(e){}
      gainNode = null;
    }
  }

  function stopMusicImmediate(){
    if (musicSource){
      try { musicSource.stop(0); } catch(e){}
    }
    disconnectSource();
  }

  async function startMusicOnce(){
    if (!musicEnabled) return;
    // If a source already exists, assume it is (or will be) playing; do NOT restart/stop
    if (musicSource) { return; }
    if (musicStarting) { return; }
    musicStarting = true;

    await ensureAudioContext();
    await ensureDecodedBuffer();
    if (!musicBuffer){ musicStarting = false; return; }

    // Build graph without stopping any prior instance (there shouldn't be one)
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = musicBuffer;
    musicSource.loop = true; // keep gapless loop
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.0; // start muted; fade prevents clicks
    musicSource.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    // Slight schedule offset + fade-in to avoid crackle
    const t0 = audioCtx.currentTime + 0.05;
    try { musicSource.start(t0); } catch(e){}
    try {
      gainNode.gain.cancelScheduledValues(0);
      gainNode.gain.setValueAtTime(0.0, t0);
      gainNode.gain.linearRampToValueAtTime(1.0, t0 + 0.35);
    } catch(e){}

    // Debounce window + mark startup complete
    setTimeout(()=>{ musicStarting = false; musicStartupComplete = true; }, 800);
  }

  async function fadeOutAndStop(durationMs = 200){
    if (!audioCtx || !gainNode || !musicSource) { stopMusicImmediate(); return; }
    const t0 = audioCtx.currentTime;
    try {
      gainNode.gain.cancelScheduledValues(0);
      gainNode.gain.setValueAtTime(gainNode.gain.value, t0);
      gainNode.gain.linearRampToValueAtTime(0.0, t0 + (durationMs/1000));
    } catch(e){}
    // stop the source after fade completes
    setTimeout(()=>{ stopMusicImmediate(); }, durationMs + 20);
  }

  // Start music on first user interaction anywhere (unless disabled)
  function startOnFirstTap(){
    try {
      if (musicEnabled) {
        ensureAudioContext().then(startMusicOnce).catch(()=>{});
      }
    } catch(e) {}
  }

  // Capture-phase listeners ensure we catch the very first interaction
  document.addEventListener('pointerdown', startOnFirstTap, { once: true, capture: true });
  document.addEventListener('touchstart', startOnFirstTap, { once: true, capture: true });
  document.addEventListener('mousedown', startOnFirstTap, { once: true, capture: true });
  document.addEventListener('keydown', startOnFirstTap, { once: true, capture: true });

  // Optional: keep Start button shortcut; guarded by once and idempotent start
  document.getElementById('playBtn')?.addEventListener('click', startOnFirstTap, { once: true });

  // Settings toggle integration (button exists from previous PR)
  const toggleBtn = document.getElementById('musicToggleBtn');
  function updateToggleText(){ 
    if (toggleBtn) {
      toggleBtn.textContent = musicEnabled ? 'Music Enabled' : 'Music Disabled';
      toggleBtn.setAttribute('aria-pressed', musicEnabled ? 'true' : 'false');
    }
  }
  async function toggleMusic(){
    musicEnabled = !musicEnabled;
    localStorage.setItem('chessrun-music-enabled', String(musicEnabled));
    updateToggleText();
    if (musicEnabled){ await startMusicOnce(); }
    else { await fadeOutAndStop(180); }
  }
  toggleBtn?.addEventListener('click', async (e) => {
    e.stopPropagation(); // Prevent event bubbling to avoid closing the settings dialog
    await ensureAudioContext();
    await toggleMusic();
  });

  // Initialize toggle label
  updateToggleText();

  // Reset Stats confirmation dialog
  function showResetConfirm(){ document.getElementById('resetStats').classList.add('show'); }
  function hideResetConfirm(){ document.getElementById('resetStats').classList.remove('show'); }

  // Open confirmation from Settings button
  document.getElementById('resetStatsBtn')?.addEventListener('click', showResetConfirm);

  // Close like other sheets
  document.getElementById('resetStatsBackdrop')?.addEventListener('click', hideResetConfirm);
  document.getElementById('resetStatsSheet')?.addEventListener('click', hideResetConfirm);

  // Prevent clicking inside the dialog from closing it
  document.querySelector('#resetStats .stats-inner')?.addEventListener('click', function(e){ e.stopPropagation(); });

  // Confirm/Cancel actions
  document.getElementById('confirmResetBtn')?.addEventListener('click', function(){
    localStorage.removeItem('chessrun-total-games');
    localStorage.removeItem('chessrun-total-score');
    localStorage.removeItem('chessrun-total-takes');
    localStorage.removeItem('chessrun-most-takes');
    localStorage.removeItem('chessrun-highscore');
    hideResetConfirm();
    // If Stats sheet is open, re-render
    if (document.getElementById('stats')?.classList.contains('show') && typeof renderStats === 'function') renderStats();
    // Return to Settings as requested
    document.getElementById('settings')?.classList.add('show');
  });

  // Cancel: hide confirm and return to Settings
  document.getElementById('cancelResetBtn')?.addEventListener('click', function(){
    hideResetConfirm();
    document.getElementById('settings')?.classList.add('show');
  });

  // Open/close Themes sheet
  function showThemes(){ document.getElementById('themes').classList.add('show'); }
  function hideThemes(){ document.getElementById('themes').classList.remove('show'); }
  document.getElementById('themesBtn')?.addEventListener('click', showThemes);
  
  // Themes: tapping backdrop or sheet returns to menu (except button taps)
  const returnToMenu = () => { hideThemes(); showMenu(); };
  document.getElementById('themesBackdrop')?.addEventListener('click', returnToMenu);
  document.getElementById('themesSheet')?.addEventListener('click', returnToMenu);

  // Prevent theme selection buttons from propagating clicks to sheet
  document.querySelectorAll('#themes .play-btn').forEach(btn => btn.addEventListener('click', e => e.stopPropagation()));

  // Theme management
  let currentTheme = localStorage.getItem('chessrun-theme') || 'chessrun'; // Load saved theme or default
  const bodyEl = document.body;
  const chessRunBtn = document.getElementById('themeChessRunBtn');
  const classicBtn  = document.getElementById('themeClassicBtn');
  const oceanBtn    = document.getElementById('themeOceanBtn');
  const neonBtn     = document.getElementById('themeNeonBtn');

  function applyTheme(theme){
    currentTheme = theme;
    localStorage.setItem('chessrun-theme', theme); // Persist theme preference
    // Remove all theme classes
    bodyEl.classList.remove('theme-classic', 'theme-ocean', 'theme-neon');
    // Apply the selected theme class
    if (theme === 'classic'){
      bodyEl.classList.add('theme-classic');
    } else if (theme === 'ocean'){
      bodyEl.classList.add('theme-ocean');
    } else if (theme === 'neon'){
      bodyEl.classList.add('theme-neon');
    }
    // Update selected state (white background via CSS .selected)
    chessRunBtn?.classList.toggle('selected', theme === 'chessrun');
    classicBtn?.classList.toggle('selected', theme === 'classic');
    oceanBtn?.classList.toggle('selected', theme === 'ocean');
    neonBtn?.classList.toggle('selected', theme === 'neon');
  }

  chessRunBtn?.addEventListener('click', function(){ applyTheme('chessrun'); });
  classicBtn?.addEventListener('click', function(){ applyTheme('classic'); });
  oceanBtn?.addEventListener('click', function(){ applyTheme('ocean'); });
  neonBtn?.addEventListener('click', function(){ applyTheme('neon'); });

  // Initialize selection state from saved preference
  applyTheme(currentTheme);
  </script>

  <script>

    const BOARD_ROWS = 11;
    const BOARD_COLS = 8;
    const TOP_ROW = BOARD_ROWS - 1;
    const WHITE = "W", BLACK = "B";

    const PROGRESSION = [
      {score: 0,   type: "P"},
      {score: 20,  type: "K"},
      {score: 50,  type: "N"},
      {score: 100, type: "B"},
      {score: 200, type: "R"},
      {score: 300, type: "Q"}
    ];

    // Board-based progression configuration
    const PIECE_ORDER = ["P", "K", "N", "B", "R", "Q"];
    const BOARD_TARGETS = { P:2, K:3, N:4, B:5, R:6, Q:7 };

    // White uses black-piece glyphs but colored via CSS; pawn uses SVG
    const WHITE_SYM = { K:"♚", N:"♞", B:"♝", R:"♜", Q:"♛" };
    const BLACK_SYM = { k:"♚", n:"♞", b:"♝", r:"♜", q:"♛" };

    let board = createEmptyBoard();
    let player = { row: 0, col: 0, type: "P" };

    let score = 0;
    let maxRowReached = 0;
    let high = 0;
    let gameOver = false;
    let inGameOverSequence = false;
    let isAdvancing = false; // lock during scroll
    let waitingForDeathTap = false;
    let killerInfo = null; // { row, col, type }
    let captures = 0;
    let boardsInCurrentStage = 0;

    // Set of immutable black pieces (including mandatory rooks and event pieces)
    let mandatoryRookKeys = new Set();

    let dragging = false;
    let dragEl = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let legalTargets = new Set();

    const $boardShell = document.querySelector(".board-shell");
    const $board = document.getElementById("board");
    const $score = document.getElementById("score");
    const $high  = document.getElementById("high");
    const $cap   = document.getElementById("captures");
    const $modal = document.getElementById("modal");
    const $menu  = document.getElementById("menu");

    const STAGE_INDEX = { P:0, K:1, N:2, B:3, R:4, Q:5 };

    const OPP_WEIGHTS = {
      near: [
        { p:0.38, k:0.24, n:0.20, b:0.10, r:0.07, q:0.01 }, // Pawn
        { p:0.34, k:0.22, n:0.20, b:0.12, r:0.08, q:0.04 }, // King
        { p:0.30, k:0.20, n:0.18, b:0.15, r:0.12, q:0.05 }, // Knight
        { p:0.26, k:0.18, n:0.16, b:0.18, r:0.16, q:0.06 }, // Bishop
        { p:0.22, k:0.16, n:0.16, b:0.20, r:0.18, q:0.08 }, // Rook
        { p:0.18, k:0.14, n:0.14, b:0.22, r:0.20, q:0.12 }, // Queen
      ],
      far: [
        { p:0.34, k:0.22, n:0.18, b:0.12, r:0.10, q:0.04 }, // Pawn
        { p:0.30, k:0.20, n:0.18, b:0.16, r:0.14, q:0.02 }, // King
        { p:0.28, k:0.18, n:0.16, b:0.18, r:0.16, q:0.04 }, // Knight
        { p:0.24, k:0.16, n:0.15, b:0.20, r:0.18, q:0.07 }, // Bishop
        { p:0.22, k:0.14, n:0.14, b:0.22, r:0.20, q:0.08 }, // Rook
        { p:0.18, k:0.12, n:0.12, b:0.24, r:0.22, q:0.12 }, // Queen
      ]
    };

    const OPP_COUNTS = [
      [10, 16],   // Pawn
      [12, 18],   // King
      [14, 20],   // Knight
      [15, 22],   // Bishop
      [16, 24],   // Rook
      [18, 26],   // Queen
    ];

    const CONSTRICTION = [0.35, 0.5, 0.6, 0.7, 0.8, 0.85];

    function currentStage(){ return STAGE_INDEX[player.type] ?? 0; }

    function nextPiece(type){
      const i = PIECE_ORDER.indexOf(type);
      return PIECE_ORDER[(i + 1) % PIECE_ORDER.length];
    }

    function pickByWeights(weights){
      let r = Math.random();
      for (const t of ["p","k","n","b","r","q"]){
        const w = weights[t] || 0;
        if ((r -= w) <= 0) return t;
      }
      return "p";
    }
    function pickFromSubset(weights, subset){
      const total = subset.reduce((s,t)=>s+(weights[t]||0),0) || 1;
      let r = Math.random() * total;
      for (const t of subset){
        const w = weights[t] || 0;
        if ((r -= w) <= 0) return t;
      }
      return subset[0];
    }

    // Stats tracking
    function loadStats(){
      const totalGames = parseInt(localStorage.getItem("chessrun-total-games")||"0",10);
      const totalScore = parseInt(localStorage.getItem("chessrun-total-score")||"0",10);
      const totalTakes = parseInt(localStorage.getItem("chessrun-total-takes")||"0",10);
      const mostTakes  = parseInt(localStorage.getItem("chessrun-most-takes")||"0",10);
      const highScore  = parseInt(localStorage.getItem("chessrun-highscore")||"0",10);
      const avgScore = totalGames ? Math.round(totalScore / totalGames) : 0;
      const avgTakes = totalGames ? Math.round(totalTakes / totalGames) : 0;
      return { totalGames, totalScore, totalTakes, mostTakes, highScore, avgScore, avgTakes };
    }
    function updateStatsOnGameEnd(finalScore, finalTakes){
      const s = loadStats();
      const totalGames = s.totalGames + 1;
      const totalScore = s.totalScore + (finalScore||0);
      const totalTakes = s.totalTakes + (finalTakes||0);
      const mostTakes  = Math.max(s.mostTakes, (finalTakes||0));
      const highScore  = Math.max(s.highScore, (finalScore||0));
      localStorage.setItem("chessrun-total-games", String(totalGames));
      localStorage.setItem("chessrun-total-score", String(totalScore));
      localStorage.setItem("chessrun-total-takes", String(totalTakes));
      localStorage.setItem("chessrun-most-takes", String(mostTakes));
      localStorage.setItem("chessrun-highscore", String(highScore));
    }
    function renderStats(){
      const s = loadStats();
      document.getElementById("statTotalGames").textContent = String(s.totalGames);
      document.getElementById("statHigh").textContent = String(s.highScore);
      document.getElementById("statTotalScore").textContent = String(s.totalScore);
      document.getElementById("statAvgScore").textContent = String(s.avgScore);
      document.getElementById("statMostTakes").textContent = String(s.mostTakes);
      document.getElementById("statTotalTakes").textContent = String(s.totalTakes);
      document.getElementById("statAvgTakes").textContent = String(s.avgTakes);
    }
    function showStats(){ renderStats(); document.getElementById("stats").classList.add("show"); }
    function hideStats(){ document.getElementById("stats").classList.remove("show"); }

    // Settings popup
    function showSettings(){ document.getElementById("settings").classList.add("show"); }
    function hideSettings(){ document.getElementById("settings").classList.remove("show"); }

    // Init
    init();
    function init(){
      high = parseInt(localStorage.getItem("chessrun-highscore") || "0", 10);
      updateHigh();
      resetBoardForNewGame();
      renderBoard();

      document.getElementById("restartBtn").addEventListener("click", restart);
      document.getElementById("menuBtn").addEventListener("click", showMenu);
      document.getElementById("playBtn").addEventListener("click", hideMenu);
      document.getElementById("statsBtn").addEventListener("click", showStats);
      document.getElementById("statsBackdrop").addEventListener("click", hideStats);
      document.getElementById("statsSheet").addEventListener("click", hideStats);

      document.getElementById("settingsBtn").addEventListener("click", showSettings);
      document.getElementById("settingsBackdrop").addEventListener("click", hideSettings);
      document.getElementById("settingsSheet").addEventListener("click", hideSettings);

      // Tap-to-move
      $board.addEventListener("click", onBoardClick);

      // Show menu initially
      showMenu();
    }
    function restart(){
      hideModal();
      captures = 0; updateCaptures();
      score = 0;
      maxRowReached = 0;
      player.type = "P";
      gameOver = false;
      inGameOverSequence = false;
      waitingForDeathTap = false; // clear waiting state
      killerInfo = null;
      isAdvancing = false;
      boardsInCurrentStage = 0;
      resetBoardForNewGame();
      renderBoard();
      updateScore();
    }

    // Menu helpers
    function showMenu(){ 
      $menu.classList.add("show");
      document.body.classList.add('menu-open');
    }
    function hideMenu(){ 
      $menu.classList.remove("show");
      document.body.classList.remove('menu-open');
    }

    // Board helpers
    function createEmptyBoard(){
      return Array.from({length: BOARD_ROWS}, () =>
        Array.from({length: BOARD_COLS}, () => null)
      );
    }
    function cloneBoard(src){
      return src.map(row => row.map(cell => {
        if (!cell) return null;
        const { color, type, highlight } = cell;
        return { color, type, highlight: !!highlight };
      }));
    }
    function placePiece(r, c, piece){ board[r][c] = piece ? { color: piece.color, type: piece.type, highlight: !!piece.highlight } : null; }
    function inBounds(r, c){ return r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS; }
    function keyOf(r, c){ return r + "," + c; }
    function isBlackAt(r,c){ const p = board[r][c]; return p && p.color === BLACK; }
    function isEmpty(r,c){ return inBounds(r,c) && !board[r][c]; }

    // New game setup
    function resetBoardForNewGame(){
      let tries = 0;
      while (tries < 80){
        board = createEmptyBoard();
        player.col = chooseSafeStartingColumn();
        player.row = 0;
        maxRowReached = 0;
        placePiece(player.row, player.col, { color: WHITE, type: player.type });

        if (generateValidSegment()) break;
        tries++;
      }
      updateScore();
      updateCaptures();
    }

    function chooseSafeStartingColumn(){
      const cols = Array.from({length: BOARD_COLS}, (_,i)=>i);
      shuffle(cols);
      return cols[0];
    }

    // --------------------- Generation with validation ---------------------
    // Reject segments that place a rook directly ahead of a pawn at start
    function isFrontRookAtStart(){
      if (player.type !== "P") return false;
      const ahead = board[1]?.[player.col] || null;
      return !!(ahead && ahead.color === BLACK && ahead.type === "R");
    }
    function forbidFrontRookForPawn(){ return !isFrontRookAtStart(); }

    function generateValidSegment(){
      mandatoryRookKeys = new Set();
      generatePuzzleSegment();
      guardStartSquare();

      // New constraint: avoid rook directly in front of player pawn
      if (!forbidFrontRookForPawn()){
        return false;
      }

      if (!hasSafeFirstMoveFromStart()){
        return false;
      }

      if (!constrictAlternatesUsingPath()) return false;

      const res = bfsSafePath(board, player.type);
      return !!(res && res.path && res.path.length);
    }

    function hasSafeFirstMoveFromStart(){
      const moves = getLegalMoves(player.type, player.row, player.col);
      for (const mv of moves){
        if (!isSquareAttackedByBlack(mv.toRow, mv.toCol)){
          return true;
        }
      }
      return false;
    }

    function generatePuzzleSegment(){
      let attempts = 0;
      const stage = currentStage();
      const [minOpp, maxOpp] = OPP_COUNTS[stage];

      while (attempts < 30){
        const savedCol = player.col;
        board = createEmptyBoard();
        player.row = 0; player.col = savedCol;
        maxRowReached = 0;
        placePiece(player.row, player.col, { color: WHITE, type: player.type });
        mandatoryRookKeys = new Set();

        const protectedSquares = new Set();
        const ok = buildTruthPathWithForcedSwitch(protectedSquares);
        if (!ok){ attempts++; continue; }

        if (player.type === "P"){
          const successTwo = ensureTwoPawnDecisionEvents(protectedSquares);
          if (!successTwo){ attempts++; continue; }
        }

        // Increase difficulty for pawn boards by biasing opposition count upward
        const targetOpp = (player.type === "P")
          ? randInt(Math.min(minOpp+2, maxOpp), maxOpp+3)
          : randInt(minOpp, maxOpp);

        placeOppositionWithConstraints(targetOpp, protectedSquares);

        if (player.type === "P"){
          restrictFirstOppositionInAdjacentColumns(protectedSquares);
          enforceMandatoryAdjacentRook(protectedSquares);
        }

        // Hard prohibition: if a rook is directly ahead of the pawn at start, reject this attempt
        if (isFrontRookAtStart()){ attempts++; continue; }

        // Intensify pawn difficulty: add extra blockers/capture choices near forward lanes
        if (player.type === "P"){
          intensifyPawnBoard(protectedSquares);
        }

        const res = bfsSafePath(board, player.type);
        if (res && res.path && res.path.length){
          enforceOppositionCountRange(minOpp, maxOpp, protectedSquares);
          const res2 = bfsSafePath(board, player.type);
          if (res2 && res2.path && res2.path.length) return;
        }

        repairEarlyRows(protectedSquares);
        enforceOppositionCountRange(minOpp, maxOpp, protectedSquares);
        attempts++;
      }

      // Fallback path: still enforce no front rook and increase pawn difficulty
      for (let r=1;r<=3;r++){ board[r][player.col] = null; guardSquareFromAttackWithImmutables(r, player.col, mandatoryRookKeys); }
      placeOppositionWithConstraints(randInt(minOpp, maxOpp), new Set());
      if (player.type === "P"){
        enforceMandatoryAdjacentRook(new Set());
        ensureTwoPawnDecisionEvents(new Set());
        // If rook ahead slipped through, relocate it immediately
        if (isFrontRookAtStart()){
          // remove the rook and place it on a random non-protected, non-start-adjacent square
          board[1][player.col] = null;
          relocateOneRookAvoidingStart();
        }
        intensifyPawnBoard(new Set());
      }
      enforceOppositionCountRange(minOpp, maxOpp, new Set());
    }

    function randomValidOppositionType(){
      // Prefer blockers and capture choices: pawns, knights, bishops; allow rook elsewhere, not front
      const types = ["p","N","B","R","Q"];
      return types[randInt(0, types.length-1)];
    }

    function intensifyPawnBoard(protectedSquares){
      // Try up to N additions around forward lanes/diagonals; keep only if solvable
      const MAX_ADDITIONS = 4;
      let added = 0;
      const cand = [];
      const pc = player.col;
      // candidate squares: rows 2..4 in same/adjacent columns, plus forward diagonals further ahead
      for (let r=2;r<=4;r++){
        for (let dc of [-1,0,1]){
          const c = pc + dc;
          if (!inBounds(r,c)) continue;
          const k = keyOf(r,c);
          if (protectedSquares.has(k)) continue;
          if (!board[r][c]) cand.push([r,c]);
        }
      }
      shuffle(cand);
      const snapshotBoard = cloneBoard(board);
      while (added < MAX_ADDITIONS && cand.length){
        const [r,c] = cand.pop();
        const t = randomValidOppositionType();
        placePiece(r,c,{ color: BLACK, type: t });
        const res = bfsSafePath(board, player.type);
        if (res && res.path && res.path.length){
          added++;
          snapshotBoard[r][c] = board[r][c]; // update snapshot to include this piece
        } else {
          // revert if not solvable
          board[r][c] = null;
        }
      }
    }

    function relocateOneRookAvoidingStart(){
      // find any empty square away from row 1, player's col, and protected start path
      const spots = [];
      for (let r=1;r<=TOP_ROW;r++){
        for (let c=0;c<BOARD_COLS;c++){
          if (r===1 && c===player.col) continue;
          if (board[r][c]) continue;
          spots.push([r,c]);
        }
      }
      shuffle(spots);
      if (spots.length){
        const [r,c] = spots[0];
        placePiece(r,c,{ color: BLACK, type: "R" });
      }
    }

    function buildTruthPathWithForcedSwitch(protectedSquares){
      let r = 0, c = player.col;

      const f1 = r + 1, f2 = r + 2;
      let firstAdvance = 1;
      if (inBounds(f2,c) && isEmpty(f1,c) && isEmpty(f2,c) && landingSafeAfterSimulatedMove(r,c,f2,c)){
        firstAdvance = (Math.random() < 0.35) ? 2 : 1;
      }
      for (let k=1;k<=firstAdvance;k++){
        board[r+k][c] = null;
        protectedSquares.add(keyOf(r+k,c));
        guardSquareFromAttackWithImmutables(r+k,c, mandatoryRookKeys);
      }
      r += firstAdvance;

      const switchRow = randInt(2, Math.min(7, TOP_ROW-2));
      let didSwitch = false;

      while (r < TOP_ROW){
        const nextR = r + 1;

        if (nextR === switchRow){
          const dir = (c === 0) ? +1 : (c === BOARD_COLS-1) ? -1 : (Math.random() < 0.5 ? -1 : +1);
          const targetC = c + dir;

          board[nextR][c] = { color: BLACK, type: "p" };
          const stage = currentStage();
          const nearWeights = OPP_WEIGHTS.near[stage];
          const targetType = pickFromSubset(nearWeights, ["n","r","b"]);
          board[nextR][targetC] = { color: BLACK, type: targetType };
          pruneAttackersForCaptureLanding(r, c, nextR, targetC);
          if (!landingSafeAfterSimulatedCapture(r, c, nextR, targetC)){
            board[nextR][c] = null;
            const altC = c - dir;
            if (inBounds(nextR, altC)){
              const altType = pickFromSubset(nearWeights, ["n","r","b"]);
              board[nextR][altC] = { color: BLACK, type: altType };
              pruneAttackersForCaptureLanding(r, c, nextR, altC);
              if (!landingSafeAfterSimulatedCapture(r, c, nextR, altC)) return false;
              protectedSquares.add(keyOf(nextR, altC));
              r = nextR; c = altC; didSwitch = true; continue;
            } else { return false; }
          }
          protectedSquares.add(keyOf(nextR, targetC));
          r = nextR; c = targetC; didSwitch = true; continue;
        }

        let moved = false;
        if (isEmpty(nextR, c) && landingSafeAfterSimulatedMove(r, c, nextR, c)){
          board[nextR][c] = null;
          protectedSquares.add(keyOf(nextR, c));
          guardSquareFromAttackWithImmutables(nextR, c, mandatoryRookKeys);
          r = nextR; moved = true;
        }
        if (!moved){
          const preferred = (Math.random() < 0.5 ? -1 : +1);
          const ordered = [preferred, preferred === -1 ? +1 : -1];
          for (const dc of ordered){
            const targetC = c + dc;
            if (!inBounds(nextR, targetC)) continue;
            if (!board[nextR][targetC]){
              const stage = currentStage();
              const nearWeights = OPP_WEIGHTS.near[stage];
              const tType = pickFromSubset(nearWeights, ["n","r","b"]);
              board[nextR][targetC] = { color: BLACK, type: tType };
            }
            pruneAttackersForCaptureLanding(r, c, nextR, targetC);
            if (landingSafeAfterSimulatedCapture(r, c, nextR, targetC)){
              protectedSquares.add(keyOf(nextR, targetC));
              r = nextR; c = targetC; moved = true; break;
            } else {
              board[nextR][targetC] = null;
            }
          }
        }
        if (!moved){
          board[nextR][c] = null;
          protectedSquares.add(keyOf(nextR, c));
          guardSquareFromAttackWithImmutables(nextR, c, mandatoryRookKeys);
          r = nextR;
        }
      }
      return didSwitch;
    }

    function ensureTwoPawnDecisionEvents(protectedSquares){
      if (player.type !== "P") return true;

      const pathRes = bfsSafePath(board, player.type);
      if (!pathRes || !pathRes.path || pathRes.path.length < 2) return false;

      const steps = [];
      for (let i = 1; i < pathRes.path.length; i++){
        const prev = pathRes.path[i-1];
        const curr = pathRes.path[i];
        if (curr.r === prev.r + 1 && curr.c === prev.c && curr.r < TOP_ROW){
          steps.push({prev, curr});
        }
      }
      if (steps.length < 2) return false;

      let added = 0;
      const usedRowCol = new Set();

      for (const step of steps){
        if (added >= 2) break;
        const { prev, curr } = step;
        const keyStep = keyOf(curr.r, curr.c);
        if (usedRowCol.has(keyStep)) continue;

        const dirs = shuffleCopy([-1, +1]);
        for (const dc of dirs){
          const targetC = curr.c + dc;
          if (!inBounds(curr.r, targetC)) continue;

          const eventKey = keyOf(curr.r, targetC);
          let created = false;
          if (!board[curr.r][targetC]){
            const stage = currentStage();
            const nearWeights = OPP_WEIGHTS.near[stage];
            const tType = pickFromSubset(nearWeights, ["n","r","b","p","k"]);
            board[curr.r][targetC] = { color: BLACK, type: tType };
            created = true;
          }

          pruneAttackersForCaptureLanding(prev.r, prev.c, curr.r, targetC);
          if (!landingSafeAfterSimulatedCapture(prev.r, prev.c, curr.r, targetC)){
            if (created && !protectedSquares.has(eventKey)) board[curr.r][targetC] = null;
            continue;
          }

          // Validate solvability after capture choice
          const savedPlayer = { ...player };
          const tempBoard = cloneBoard(board);
          tempBoard[prev.r][prev.c] = null;
          tempBoard[curr.r][targetC] = { color: WHITE, type: "P" };
          player.row = curr.r; player.col = targetC;
          const captureRes = bfsSafePath(tempBoard, player.type);
          player = savedPlayer;
          if (!captureRes || !captureRes.path || captureRes.path.length === 0){
            if (created && !protectedSquares.has(eventKey)) board[curr.r][targetC] = null;
            continue;
          }

          protectedSquares.add(eventKey);
          mandatoryRookKeys.add(eventKey);
          usedRowCol.add(keyStep);
          added++;
          break;
        }
      }

      return added === 2;
    }

    function placeOppositionWithConstraints(targetCount, protectedSquares){
      const forbidden = new Set(protectedSquares);
      let current = countBlackPieces();

      const near = collectOppCandidates(forbidden, "near");
      current += placeOppFromCandidates(near, targetCount - current, forbidden);

      if (current < targetCount){
        const far = collectOppCandidates(forbidden, "far");
        current += placeOppFromCandidates(far, targetCount - current, forbidden);
      }

      // Safety cleanup: remove any black pieces that ended up on TOP_ROW
      for (let c = 0; c < BOARD_COLS; c++){
        const p = board[TOP_ROW][c];
        if (p && p.color === BLACK){
          board[TOP_ROW][c] = null;
        }
      }

      while (countBlackPieces() > targetCount){
        const list = [];
        for (let r=1;r<=TOP_ROW;r++){
          for (let c=0;c<BOARD_COLS;c++){
            const p = board[r][c];
            const k = keyOf(r,c);
            if (p && p.color === BLACK && !forbidden.has(k) && !mandatoryRookKeys.has(k)){
              list.push({r,c, d: Math.abs(c - player.col) + Math.abs(r - 0)});
            }
          }
        }
        if (!list.length) break;
        list.sort((a,b)=>b.d - a.d);
        const rem = list[0];
        board[rem.r][rem.c] = null;
      }
    }

    function collectOppCandidates(forbidden, bias){
      const cand = [];
      for (let r=1;r<=TOP_ROW-1;r++){
        for (let c=0;c<BOARD_COLS;c++){
          if (board[r][c]) continue;
          const k = keyOf(r,c);
          if (forbidden.has(k)) continue;
          const nearLane = Math.abs(c - player.col) <= 1;
          if ((bias === "near" && nearLane) || (bias === "far" && !nearLane)){
            cand.push({r,c,bias});
          }
        }
      }
      shuffle(cand);
      return cand;
    }

    function placeOppFromCandidates(candidates, need, forbidden){
      let placed = 0;
      for (const cand of candidates){
        if (placed >= need) break;
        if (board[cand.r][cand.c]) continue;
        const stage = currentStage();
        const weights = OPP_WEIGHTS[cand.bias][stage];
        const type = pickByWeights(weights);
        board[cand.r][cand.c] = { color: BLACK, type };
        if (attacksAnyProtected(cand.r, cand.c, type, forbidden)){
          board[cand.r][cand.c] = null;
          continue;
        }
        placed++;
      }
      return placed;
    }

    function restrictFirstOppositionInAdjacentColumns(protectedSquares){
      for (const dc of [-1, +1]){
        const col = player.col + dc;
        if (!inBounds(1, col)) continue;
        let firstRow = -1;
        for (let r = 1; r <= TOP_ROW; r++){
          const p = board[r][col];
          if (p && p.color === BLACK){ firstRow = r; break; }
        }
        if (firstRow === -1) continue;
        const p = board[firstRow][col];
        if (p.type !== "n" && p.type !== "r"){
          board[firstRow][col] = { color: BLACK, type: (Math.random()<0.5?"n":"r") };
        }
        const type = board[firstRow][col].type;
        if (attacksAnyProtected(firstRow, col, type, protectedSquares)){
          let moved = false;
          for (let rr = firstRow + 1; rr <= TOP_ROW - 1; rr++){
            if (!board[rr][col]){
              board[rr][col] = { color: BLACK, type };
              board[firstRow][col] = null;
              if (!attacksAnyProtected(rr, col, type, protectedSquares)){
                moved = true; break;
              } else {
                board[firstRow][col] = { color: BLACK, type };
                board[rr][col] = null;
              }
            }
          }
          if (!moved) board[firstRow][col] = null;
        }
      }
    }

    function enforceMandatoryAdjacentRook(protectedSquares){
      let obstacleRow = -1;
      for (let r=1; r<=TOP_ROW; r++){
        const p = board[r][player.col];
        if (p && p.color === BLACK){ obstacleRow = r; break; }
      }
      if (obstacleRow === -1) obstacleRow = 1;

      const candidates = [];
      if (player.col - 1 >= 0){
        for (let r=1; r<=obstacleRow; r++){
          if (!board[r][player.col - 1]) candidates.push({r, c: player.col - 1});
        }
      }
      if (player.col + 1 < BOARD_COLS){
        for (let r=1; r<=obstacleRow; r++){
          if (!board[r][player.col + 1]) candidates.push({r, c: player.col + 1});
        }
      }
      shuffle(candidates);

      let placed = false;
      for (const cand of candidates){
        board[cand.r][cand.c] = { color: BLACK, type: "r" };
        const k = keyOf(cand.r, cand.c);
        mandatoryRookKeys.add(k);

        if (attacksAnyProtected(cand.r, cand.c, "r", protectedSquares)){
          let moved = false;
          for (let rr = cand.r; rr >= 1; rr--){
            if (!board[rr][cand.c]){
              board[rr][cand.c] = { color: BLACK, type: "r" };
              board[cand.r][cand.c] = null;
              const kk = keyOf(rr, cand.c);
              mandatoryRookKeys.delete(k);
              mandatoryRookKeys.add(kk);
              if (!attacksAnyProtected(rr, cand.c, "r", protectedSquares)){ moved = true; break; }
              board[cand.r][cand.c] = { color: BLACK, type: "r" };
              board[rr][cand.c] = null;
              mandatoryRookKeys.delete(kk);
              mandatoryRookKeys.add(k);
            }
          }
        }

        placed = true; break;
      }

      if (!placed){
        const adjCols = [player.col - 1, player.col + 1].filter(c => c >= 0 && c < BOARD_COLS);
        for (const ac of adjCols){
          for (let r=1; r<=obstacleRow; r++){
            const k = keyOf(r, ac);
            board[r][ac] = { color: BLACK, type: "r" };
            mandatoryRookKeys.add(k);
            placed = true; break;
          }
          if (placed) break;
        }
      }
    }

    function constrictAlternatesUsingPath(){
      const stage = currentStage();
      const [minOpp, maxOpp] = OPP_COUNTS[stage];
      const baseIntensity = CONSTRICTION[stage];

      let intensity = baseIntensity;
      for (let attempt = 0; attempt < 7; attempt++){
        const original = cloneBoard(board);

        const res = bfsSafePath(board, player.type);
        if (!res || !res.path || !res.path.length) return false;

        const pathSet = new Set(res.path.map(p => keyOf(p.r, p.c)));

        // Existing off-path opposition placement (harder patterns)
        for (let r=1; r<=TOP_ROW-1; r++){
          for (let c=0; c<BOARD_COLS; c++){
            const k = keyOf(r,c);
            if (pathSet.has(k)) continue;
            if (board[r][c]) continue;
            if (Math.random() > intensity) continue;

            const bias = (Math.abs(c - player.col) <= 1) ? "near" : "far";
            const weights = OPP_WEIGHTS[bias][stage];
            const t = pickByWeights(weights);

            board[r][c] = { color: BLACK, type: t };
            let attacksPath = false;
            for (const pk of pathSet){
              const [pr, pc] = pk.split(",").map(Number);
              if (blackAttacksSquare(t, r, c, pr, pc)){ attacksPath = true; break; }
            }
            if (attacksPath){ board[r][c] = null; }
          }
        }

        enforceOppositionCountRange(minOpp, maxOpp, pathSet);

        // New: limit safe channels to 2 or 3 while preserving the truth path
        const initialChannels = Math.random() < 0.5 ? 2 : 3;
        pruneSafeChannels(initialChannels, pathSet);

        const res2 = bfsSafePath(board, player.type);
        if (res2 && res2.path && res2.path.length){
          // Optional: if we started with 3 channels, try pruning to 2 for increased difficulty
          if (initialChannels === 3 && Math.random() < 0.5){ 
            const beforeSecondary = cloneBoard(board);
            pruneSafeChannels(2, pathSet); 
            const res3 = bfsSafePath(board, player.type);
            if (res3 && res3.path && res3.path.length){ 
              return true; // Successfully pruned to 2 channels
            }
            // Secondary pruning removed the path, revert to 3-channel board
            board = beforeSecondary;
          }
          return true;
        }
        // revert and reduce intensity, retry
        board = original;
        intensity *= 0.85;
      }
      return false;
    }

    // Compute safe frontiers per row: squares from which a safe path to TOP_ROW could exist
    function computeSafeFrontiers(){
      const frontiers = Array.from({length: BOARD_ROWS}, () => new Set());
      // Mark squares that are currently empty or white and not attacked
      for (let r=0; r<BOARD_ROWS; r++){
        for (let c=0; c<BOARD_COLS; c++){
          if (!isEmpty(r,c) && !(board[r][c] && board[r][c].color===WHITE)) continue;
          if (!isSquareAttackedByBlack(r,c)) frontiers[r].add(keyOf(r,c));
        }
      }
      return frontiers;
    }

    // Select at most maxChannels columns to keep as potential paths; block others
    function pruneSafeChannels(maxChannels, pathSet){
      const frontiers = computeSafeFrontiers();
      // Identify candidate columns by presence across rows
      const colScore = new Map();
      for (let r=1; r<=TOP_ROW; r++){
        for (const k of frontiers[r]){
          const [, cStr] = k.split(","); const c = parseInt(cStr,10);
          colScore.set(c, (colScore.get(c)||0)+1);
        }
      }
      const cols = Array.from(colScore.entries()).sort((a,b)=>b[1]-a[1]).map(e=>e[0]);
      if (!cols.length) return; // nothing to prune
      const keepCount = Math.min(maxChannels, cols.length);
      const keepCols = new Set(cols.slice(0, keepCount));

      const stage = currentStage();
      const weights = OPP_WEIGHTS.far[stage];

      // For frontiers not in keepCols and not on the truth path, place blocking pieces that do not attack truth path
      for (let r=1; r<=TOP_ROW-1; r++){
        for (const k of frontiers[r]){
          const [rrStr, ccStr] = k.split(","); const rr = parseInt(rrStr,10); const cc = parseInt(ccStr,10);
          if (keepCols.has(cc)) continue;
          if (pathSet.has(k)) continue; // never block truth path squares
          if (board[rr][cc]) continue;
          // Choose a blocker biased to create complexity but avoid attacking truth path
          const t = pickFromSubset(weights, ["r","b","q"]);
          board[rr][cc] = { color: BLACK, type: t };
          // If this newly placed piece attacks any truth-path square, remove it
          let attacksPath = false;
          for (const pk of pathSet){
            const [pr, pc] = pk.split(",").map(Number);
            if (blackAttacksSquare(t, rr, cc, pr, pc)){ attacksPath = true; break; }
          }
          if (attacksPath){ board[rr][cc] = null; }
        }
      }
    }

    function guardStartSquare(){
      guardSquareFromAttackWithImmutables(player.row, player.col, mandatoryRookKeys);
    }

    function repairEarlyRows(protectedSquares){
      const c = player.col;
      for (let r=1; r<=3; r++){
        const forwardOk = isEmpty(r, c) && landingSafeAfterSimulatedMove(r-1, c, r, c);
        const leftOk = (c-1>=0) && isBlackAt(r, c-1) && landingSafeAfterSimulatedCapture(r-1, c, r, c-1);
        const rightOk= (c+1<BOARD_COLS) && isBlackAt(r, c+1) && landingSafeAfterSimulatedCapture(r-1, c, r, c+1);
        if (forwardOk || leftOk || rightOk) continue;

        for (const dc of shuffleCopy([-1,+1])){
          const nc = c + dc; if (!inBounds(r, nc)) continue;
          const stage = currentStage();
          const nearWeights = OPP_WEIGHTS.near[stage];
          const tType = pickFromSubset(nearWeights, ["n","r","b"]);
          board[r][nc] = { color: BLACK, type: tType };
          pruneAttackersForCaptureLanding(r-1, c, r, nc);
          if (landingSafeAfterSimulatedCapture(r-1, c, r, nc)){
            protectedSquares.add(keyOf(r, nc));
            return;
          } else { board[r][nc] = null; }
        }
        board[r][c] = null;
        guardSquareFromAttackWithImmutables(r, c, mandatoryRookKeys);
        protectedSquares.add(keyOf(r, c)); return;
      }
    }

    function enforceOppositionCountRange(min, max, forbidden){
      let count = countBlackPieces();
      if (count < min){
        const need = min - count;
        const extras = collectOppCandidates(forbidden, "far");
        placeOppFromCandidates(extras, need, forbidden);
      }
      while ((count = countBlackPieces()) > max){
        const list = [];
        for (let r=0;r<BOARD_ROWS;r++){
          for (let c=0;c<BOARD_COLS;c++){
            const p = board[r][c];
            const k = keyOf(r,c);
            if (p && p.color === BLACK && !forbidden.has(k) && !mandatoryRookKeys.has(k)){
              list.push({r,c, d: Math.abs(c - player.col) + Math.abs(r - 0)});
            }
          }
        }
        if (!list.length) break;
        list.sort((a,b)=>b.d - a.d);
        const rem = list[0];
        board[rem.r][rem.c] = null;
      }
    }

    // --------------------- Unified BFS: solvable path for current piece ---------------------
    function bfsSafePath(b, type){
      const start = { r: player.row, c: player.col, b: cloneBoard(b) };
      const queue = [start];
      const seen = new Set([stateKeyGeneric(start, type)]);
      const parent = new Map();
      const stateMap = new Map([[stateKeyGeneric(start, type), start]]);

      while (queue.length){
        const s = queue.shift();
        if (s.r === TOP_ROW){ return reconstructPathGeneric(s, parent, stateMap, type); }

        const moves = getMovesOnBoardGeneric(s.b, type, s.r, s.c);
        for (const mv of moves){
          const next = simulateMoveOnBoardGeneric(s, type, mv);
          if (!next) continue;
          const k = stateKeyGeneric(next, type); if (seen.has(k)) continue;
          seen.add(k); parent.set(k, stateKeyGeneric(s, type)); stateMap.set(k, next); queue.push(next);
        }
      }
      return null;
    }
    function reconstructPathGeneric(endState, parent, stateMap, type){
      const path = []; let k = stateKeyGeneric(endState, type);
      while (k){ const st = stateMap.get(k); path.push({ r: st.r, c: st.c }); k = parent.get(k); }
      path.reverse(); return { path };
    }
    function stateKeyGeneric(st, type){ return type + "|" + st.r + "|" + st.c + "|" + hashBoard(st.b); }

    function hashBoard(b){
      let s = "";
      for (let r=0;r<BOARD_ROWS;r++){
        for (let c=0;c<BOARD_COLS;c++){
          const p = b[r][c]; s += (p ? (p.color === BLACK ? p.type : p.type.toLowerCase()) : ".");
        }
      }
      return s;
    }

    function getMovesOnBoardGeneric(b, type, r, c){
      const out = [];
      const add = (rr, cc) => {
        if (!inBounds(rr, cc)) return;
        const dest = b[rr][cc];
        if (!dest || dest.color === BLACK){
          out.push({ toRow: rr, toCol: cc });
        }
      };
      if (type === "P"){
        const f1 = r + 1, f2 = r + 2;
        if (inBounds(f1, c) && !b[f1][c]) add(f1, c);
        if (r === 0 && inBounds(f2, c) && !b[f1][c] && !b[f2][c]) add(f2, c);
        if (inBounds(f1, c-1) && b[f1][c-1] && b[f1][c-1].color === BLACK) add(f1, c-1);
        if (inBounds(f1, c+1) && b[f1][c+1] && b[f1][c+1].color === BLACK) add(f1, c+1);
      } else if (type === "K"){
        for (let dr=-1; dr<=1; dr++){
          for (let dc=-1; dc<=1; dc++){
            if (dr===0 && dc===0) continue;
            add(r+dr, c+dc);
          }
        }
      } else if (type === "N"){
        [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
      } else if (type === "B"){
        rayOnBoard(b, r, c, [[1,1],[1,-1],[-1,1],[-1,-1]], out);
      } else if (type === "R"){
        rayOnBoard(b, r, c, [[1,0],[-1,0],[0,1],[0,-1]], out);
      } else if (type === "Q"){
        rayOnBoard(b, r, c, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], out);
      }
      return out;
    }
    function rayOnBoard(b, r, c, dirs, out){
      for (const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc;
        while (inBounds(rr,cc)){
          const d = b[rr][cc];
          if (!d){ out.push({toRow:rr, toCol:cc}); }
          else { if (d.color===BLACK) out.push({toRow:rr, toCol:cc}); break; }
          rr+=dr; cc+=dc;
        }
      }
    }
    function simulateMoveOnBoardGeneric(state, type, mv){
      const nb = cloneBoard(state.b);
      nb[state.r][state.c] = null; nb[mv.toRow][mv.toCol] = { color: WHITE, type };
      if (isSquareAttackedByBlackOnBoard(nb, mv.toRow, mv.toCol)) return null;
      return { r: mv.toRow, c: mv.toCol, b: nb };
    }

    // --------------------- Attack/defense utilities ---------------------
    function landingSafeAfterSimulatedMove(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC];
      const prevTo   = board[toR][toC];
      board[fromR][fromC] = null;
      board[toR][toC] = { color: WHITE, type: player.type };
      const attacked = isSquareAttackedByBlack(toR, toC);
      board[fromR][fromC] = prevFrom || null;
      board[toR][toC] = prevTo || null;
      return !attacked;
    }
    function landingSafeAfterSimulatedCapture(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC];
      const prevTo   = board[toR][toC];
      board[fromR][fromC] = null;
      board[toR][toC] = { color: WHITE, type: player.type };
      const attacked = isSquareAttackedByBlack(toR, toC);
      board[fromR][fromC] = prevFrom || null;
      board[toR][toC] = prevTo || null;
      return !attacked;
    }
    function pruneAttackersForCaptureLanding(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC];
      const prevTo   = board[toR][toC];
      board[fromR][fromC] = null;
      board[toR][toC] = { color: WHITE, type: player.type };
      let guard = 0;
      while (isSquareAttackedByBlack(toR, toC) && guard < 300){
        const atks = attackersOfSquare(toR, toC);
        if (!atks.length) break;
        atks.sort((a,b)=>((a.row-toR)**2+(a.col-toC)**2)-((b.row-toR)**2+(b.col-toC)**2));
        const kill = atks[0];
        const kk = keyOf(kill.row, kill.col);
        if (!mandatoryRookKeys.has(kk)) board[kill.row][kill.col] = null;
        guard++;
      }
      board[fromR][fromC] = prevFrom || null;
      board[toR][toC] = prevTo || null;
    }

    function isSquareAttackedByBlack(r, c){
      for (let rr = 0; rr < BOARD_ROWS; rr++){
        for (let cc = 0; cc < BOARD_COLS; cc++){
          const p = board[rr][cc];
          if (!p || p.color !== BLACK) continue;
          if (blackAttacksSquare(p.type, rr, cc, r, c)) return true;
        }
      }
      return false;
    }
    function attackersOfSquare(r, c){
      const list = [];
      for (let rr=0; rr<BOARD_ROWS; rr++){
        for (let cc=0; cc<BOARD_COLS; cc++){
          const p = board[rr][cc];
          if (!p || p.color !== BLACK) continue;
          if (blackAttacksSquare(p.type, rr, cc, r, c)) list.push({row: rr, col: cc, type: p.type});
        }
      }
      return list;
    }
    function blackAttacksSquare(type, br, bc, tr, tc){
      const dr = tr - br, dc = tc - bc;
      if (type === "p"){
        return (tr === br - 1) && (tc === bc - 1 || tc === bc + 1);
      }
      if (type === "k"){
        return Math.max(Math.abs(dr), Math.abs(dc)) === 1;
      }
      if (type === "n"){
        return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
      }
      if (type === "b" || type === "r" || type === "q"){
        const dirs = [];
        if (type !== "r") dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        if (type !== "b") dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [drr,dcc] of dirs){
          let rr = br + drr, cc = bc + dcc;
          while (inBounds(rr, cc)){
            if (rr === tr && cc === tc) return true;
            const occ = board[rr][cc];
            if (occ) break;
            rr += drr; cc += dcc;
          }
        }
        return false;
      }
      return false;
    }
    function guardSquareFromAttackWithImmutables(r, c, immutables){
      let guard = 0;
      while (isSquareAttackedByBlack(r, c) && guard < 300){
        const atks = attackersOfSquare(r, c);
        if (!atks.length) break;
        atks.sort((a,b)=>((a.row-r)**2+(a.col-c)**2)-((b.row-r)**2+(b.col-c)**2));
        const kill = atks[0];
        const kk = keyOf(kill.row, kill.col);
        if (!immutables.has(kk)) board[kill.row][kill.col] = null;
        guard++;
      }
    }
    function attacksAnyProtected(br, bc, type, protectedSquares){
      for (const k of protectedSquares){
        const [r,c] = k.split(",").map(Number);
        if (blackAttacksSquare(type, br, bc, r, c)) return true;
      }
      return false;
    }

    // --------------------- Drag-and-drop & Tap UI ---------------------
    function onPointerDown(e){
      if (gameOver || inGameOverSequence || isAdvancing) return;
      const sq = e.target.closest(".sq");
      if (!sq) return;
      const r = parseInt(sq.dataset.row, 10);
      const c = parseInt(sq.dataset.col, 10);
      if (r !== player.row || c !== player.col) return;

      const moves = getLegalMoves(player.type, player.row, player.col);
      legalTargets = new Set(moves.map(m => keyOf(m.toRow, m.toCol)));

      dragging = true;

      dragEl = createPieceVisual({ color: WHITE, type: player.type }, true);
      document.body.appendChild(dragEl);
      const rect = sq.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;

      positionDragEl(e.clientX - dragOffsetX, e.clientY - rect.top, rect.width, rect.height);

      dragEl.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    }

    function onPointerMove(e){
      if (!dragging || !dragEl) return;
      const squareW = $board.getBoundingClientRect().width / BOARD_COLS;
      const squareH = $board.getBoundingClientRect().height / BOARD_ROWS;
      positionDragEl(e.clientX - dragOffsetX, e.clientY - dragOffsetY, squareW, squareH);
    }

    function onPointerUp(e){
      if (!dragging) return;
      dragging = false;

      const drop = pointerToBoardSquare(e.clientX, e.clientY);
      if (drop){
        const k = keyOf(drop.r, drop.c);
        if (legalTargets.has(k)){
          performMove(drop.r, drop.c);
          renderBoard();
        }
      }
      if (dragEl && dragEl.parentNode) dragEl.parentNode.removeChild(dragEl);
      dragEl = null;
    }

    // Tap-to-move
    function onBoardClick(e){
      if (gameOver || dragging || isAdvancing) return;

      // If we're in the game-over sequence and waiting for tap, any board tap triggers death
      if (inGameOverSequence && waitingForDeathTap){
        performDeathCaptureAndScheduleEnd();
        return;
      }

      // Block input during game-over sequence (after death tap, before game over modal)
      if (inGameOverSequence) return;
      const sq = e.target.closest(".sq");
      if (!sq) return;
      const r = parseInt(sq.dataset.row, 10);
      const c = parseInt(sq.dataset.col, 10);
      if (r === player.row && c === player.col) return;

      const moves = getLegalMoves(player.type, player.row, player.col);
      const isLegal = moves.some(m => m.toRow === r && m.toCol === c);
      if (isLegal){
        performMove(r, c);
        renderBoard();
      }
    }

    function positionDragEl(left, top, squareW, squareH){
      dragEl.style.position = "fixed";
      dragEl.style.left = `${left}px`;
      dragEl.style.top  = `${top}px`;
      dragEl.style.width  = `${squareW}px`;
      dragEl.style.height = `${squareH}px`;
      dragEl.style.zIndex = "100";
      dragEl.style.pointerEvents = "none";
    }

    function pointerToBoardSquare(clientX, clientY){
      const rect = $board.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) return null;
      const col = Math.floor(x / (rect.width / BOARD_COLS));
      const uiRow = Math.floor(y / (rect.height / BOARD_ROWS));
      const row = TOP_ROW - uiRow; // top in UI = highest row index
      return { r: row, c: col };
    }

    // --------------------- Gameplay ---------------------
    function performMove(toRow, toCol){
      if (gameOver || inGameOverSequence || isAdvancing) return;

      if (toRow > maxRowReached){
        score += (toRow - maxRowReached);
        maxRowReached = toRow;
        updateScore();
      }

      const dest = board[toRow][toCol];
      if (dest && dest.color === BLACK){
        captures++;
        updateCaptures();
      }

      board[player.row][player.col] = null;
      player.row = toRow; player.col = toCol;
      placePiece(player.row, player.col, { color: WHITE, type: player.type });

      if (isSquareAttackedByBlack(player.row, player.col)){
        revealKillerThenCaptureAndEnd();
        return;
      }

      if (player.row === TOP_ROW){
        boardsInCurrentStage++;
        if (boardsInCurrentStage >= BOARD_TARGETS[player.type]){
          player.type = nextPiece(player.type);
          boardsInCurrentStage = 0;
          placePiece(player.row, player.col, { color: WHITE, type: player.type });
        }
        smoothAdvanceAndRegenerate();
      }
    }

    function buildNextBoardFromCurrentTop(){
      const seed = createEmptyBoard();
      for (let c = 0; c < BOARD_COLS; c++){
        seed[0][c] = board[player.row][c] ? { ...board[player.row][c] } : null;
      }

      const saved = {
        board: board,
        player: { ...player },
        mandatory: new Set(mandatoryRookKeys),
        maxRow: maxRowReached,
      };

      board = seed;
      player.row = 0;
      maxRowReached = 0;
      mandatoryRookKeys = new Set();

      let tries = 0;
      while (tries < 80){
        if (generateValidSegment()) break;
        tries++;
      }
      const nextBoard = cloneBoard(board);

      board = saved.board;
      player = saved.player;
      mandatoryRookKeys = saved.mandatory;
      maxRowReached = saved.maxRow;

      return nextBoard;
    }

    function smoothAdvanceAndRegenerate(){
      isAdvancing = true;

      const prevBoard = cloneBoard(board);
      const nextBoard = buildNextBoardFromCurrentTop();

      const shellRect = $boardShell.getBoundingClientRect();
      const boardHeight = shellRect.height;
      const squareHeight = boardHeight / BOARD_ROWS;
      const incomingRows = BOARD_ROWS - 1;
      const incomingHeight = incomingRows * squareHeight;

      const incomingRowsArray = [];
      for (let r = TOP_ROW; r >= 1; r--) incomingRowsArray.push(nextBoard[r]);

      const currentRowsArray = [];
      for (let r = TOP_ROW; r >= 0; r--) currentRowsArray.push(prevBoard[r]);

      const strip = document.createElement("div");
      strip.className = "strip-scroller";
      strip.style.height = `${incomingHeight + boardHeight}px`;
      strip.style.transform = `translateY(-${incomingHeight}px)`;

      const incomingPart = document.createElement("div");
      incomingPart.className = "strip-part";
      incomingPart.style.height = `${incomingHeight}px`;
      const incomingGrid = renderRowsGrid(incomingRowsArray, TOP_ROW + incomingRows);
      incomingPart.appendChild(incomingGrid);

      const currentPart = document.createElement("div");
      currentPart.className = "strip-part";
      currentPart.style.height = `${boardHeight}px`;
      const currentGrid = renderRowsGrid(currentRowsArray, TOP_ROW);
      currentPart.appendChild(currentGrid);

      strip.appendChild(incomingPart);
      strip.appendChild(currentPart);

      $boardShell.appendChild(strip);
      $board.style.opacity = "0";

      requestAnimationFrame(() => {
        strip.classList.add("transition");
        strip.style.transform = `translateY(0px)`;
      });

      strip.addEventListener("transitionend", () => {
        board = nextBoard;
        player.row = 0;
        maxRowReached = 0;

        renderBoard();
        $board.style.opacity = "1";
        if (strip.parentNode) strip.parentNode.removeChild(strip);

        isAdvancing = false;
      }, { once: true });
    }

    function renderRowsGrid(rowsArray, startV){
      const grid = document.createElement("div");
      grid.className = "strip-grid";
      grid.style.gridTemplateRows = `repeat(${rowsArray.length}, 1fr)`;

      const frag = document.createDocumentFragment();
      for (let i = 0; i < rowsArray.length; i++){
        const vIdx = startV - i;
        const row = rowsArray[i];
        for (let c = 0; c < BOARD_COLS; c++){
          const sq = document.createElement("div");
          sq.className = "sq " + (((vIdx + c) % 2 === 0) ? "light" : "dark");
          const p = row[c];
          if (p){
            const pieceEl = createPieceVisual(p, false);
            sq.appendChild(pieceEl);
          }
          frag.appendChild(sq);
        }
      }
      grid.appendChild(frag);
      return grid;
    }

    function revealKillerThenCaptureAndEnd(){
      inGameOverSequence = true;

      const atks = attackersOfSquare(player.row, player.col);
      if (!atks.length){
        endGame();
        return;
      }
      atks.sort((a,b)=>((a.row-player.row)**2+(a.col-player.col)**2)-((b.row-player.row)**2+(b.col-player.col)**2));
      const killer = atks[0];

      const kp = board[killer.row][killer.col];
      if (kp){ kp.highlight = true; }
      renderBoard();

      // Store killer info and wait for user tap
      killerInfo = { row: killer.row, col: killer.col, type: killer.type };
      waitingForDeathTap = true;
    }

    function performDeathCaptureAndScheduleEnd(){
      // Guard: only proceed if we're actually waiting for death tap and have killer info
      if (!waitingForDeathTap || !killerInfo) return;
      const { row, col, type } = killerInfo;
      const moving = board[row][col] ? { ...board[row][col] } : { color: BLACK, type, highlight: true };
      board[row][col] = null;
      placePiece(player.row, player.col, moving);
      renderBoard();

      waitingForDeathTap = false;
      killerInfo = null;

      setTimeout(() => { endGame(); }, 1000); // 1 second after death
    }

    function updateScore(){
      $score.textContent = String(score);
      if (score > high){
        high = score;
        localStorage.setItem("chessrun-highscore", String(high));
        updateHigh();
      }
    }
    function updateHigh(){ $high.textContent = String(high); }
    function updateCaptures(){ $cap.textContent = String(captures); }

    function applyProgression(){
      let newType = player.type;
      for (let i = PROGRESSION.length - 1; i >= 0; i--){
        if (score >= PROGRESSION[i].score){ newType = PROGRESSION[i].type; break; }
      }
      if (newType !== player.type){
        player.type = newType;
        placePiece(player.row, player.col, { color: WHITE, type: player.type });
      }
    }

    function getLegalMoves(type, r, c){
      const moves = [];
      const add = (rr, cc) => {
        if (!inBounds(rr, cc)) return;
        const dest = board[rr][cc];
        if (!dest || dest.color === BLACK){
          out.push({ toRow: rr, toCol: cc });
        }
      };
      const out = [];
      if (type === "P"){
        const f1 = r + 1;
        const f2 = r + 2;
        if (inBounds(f1, c) && !board[f1][c]) out.push({toRow:f1, toCol:c});
        if (r === 0 && inBounds(f2, c) && !board[f1][c] && !board[f2][c]) out.push({toRow:f2, toCol:c});
        if (inBounds(f1, c-1) && isBlackAt(f1, c-1)) out.push({toRow:f1, toCol:c-1});
        if (inBounds(f1, c+1) && isBlackAt(f1, c+1)) out.push({toRow:f1, toCol:c+1});
      }
      else if (type === "K"){
        for (let dr = -1; dr <= 1; dr++){
          for (let dc = -1; dc <= 1; dc++){
            if (dr === 0 && dc === 0) continue;
            add(r + dr, c + dc);
          }
        }
      }
      else if (type === "N"){
        [[ 2, 1],[ 2,-1],[-2, 1],[-2,-1],[ 1, 2],[ 1,-2],[-1, 2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
      }
      else if (type === "B"){
        ray(r,c,[[1,1],[1,-1],[-1,1],[-1,-1]],out);
      }
      else if (type === "R"){
        ray(r,c,[[1,0],[-1,0],[0,1],[0,-1]],out);
      }
      else if (type === "Q"){
        ray(r,c,[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],out);
      }
      return out;
    }
    function ray(r,c,dirs,out){
      for (const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc;
        while (inBounds(rr,cc)){
          const d = board[rr][cc];
          if (!d){ out.push({toRow:rr,toCol:cc}); }
          else { if (d.color===BLACK) out.push({toRow:rr,toCol:cc}); break; }
          rr+=dr; cc+=dc;
        }
      }
    }

    function renderBoard(){
      const frag = document.createDocumentFragment();
      $board.innerHTML = "";
      for (let vRow = BOARD_ROWS - 1; vRow >= 0; vRow--){
        for (let c = 0; c < BOARD_COLS; c++){
          const sq = document.createElement("div");
          sq.className = "sq " + (((vRow + c) % 2 === 0) ? "light" : "dark");
          sq.dataset.row = String(vRow);
          sq.dataset.col = String(c);
          const p = board[vRow][c];
          if (p){
            const pieceEl = createPieceVisual(p, false);
            sq.appendChild(pieceEl);
          }
          frag.appendChild(sq);
        }
      }
      $board.appendChild(frag);
    }

    function createPieceVisual(p, isDrag){
      const span = document.createElement("span");
      const colorClass = (p.color === WHITE ? "white" : "black");
      span.className = "piece " + colorClass + (p.highlight ? " danger" : "");
      if (p.type === "P" || p.type === "p"){
        span.innerHTML = pawnSVG(p.color, p.highlight);
      } else {
        span.textContent = (p.color === WHITE ? WHITE_SYM[p.type] : BLACK_SYM[p.type.toLowerCase()]);
      }
      if (isDrag){
        span.style.display = "flex";
        span.style.alignItems = "center";
        span.style.justifyContent = "center";
        span.style.background = "rgba(0,0,0,0.0)";
      }
      return span;
    }

    // Pawn SVG; use currentColor to inherit theme colors; killer highlight = RED
    function pawnSVG(color, highlight=false){
      const stroke = "none";
      const fill = "currentColor"; // always inherit from .piece color
      return `
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <circle cx="50" cy="24" r="14" fill="${fill}" stroke="${stroke}" stroke-width="0"/>
          <path d="M35 40
                   C35 36, 65 36, 65 40
                   C65 46, 60 52, 54 56
                   C60 60, 62 66, 62 72
                   L38 72
                   C38 66, 40 60, 46 56
                   C40 52, 35 46, 35 40Z"
                fill="${fill}" stroke="${stroke}" stroke-width="0"/>
          <rect x="28" y="72" width="44" height="8" rx="2" ry="2" fill="${fill}" stroke="${stroke}" stroke-width="0"/>
          <rect x="22" y="80" width="56" height="8" rx="2" ry="2" fill="${fill}" stroke="${stroke}" stroke-width="0"/>
        </svg>
      `;
    }

    // Position and populate the Game Over card over the board
    function showGameOverCard(){
      const card = document.getElementById('goCard');
      const rect = $boardShell.getBoundingClientRect();
      const squareW = rect.width / BOARD_COLS;

      // Leave half a chess square on left and right
      const left = rect.left + (squareW / 2);
      const width = rect.width - squareW;
      const top  = rect.top;
      const height = rect.height; // cover most of the chessboard (full height of board)

      card.style.left = `${left}px`;
      card.style.top  = `${top}px`;
      card.style.width = `${width}px`;
      card.style.height = `${height}px`;

      // Populate gold text entries
      const s = loadStats();
      const mostCaptures = s.mostTakes ?? 0;

      card.innerHTML = [
        `<div class="go-item-label">Score</div>`,
        `<div class="go-item-value">${score}</div>`,
        `<div class="go-item-label go-white">High Score</div>`,
        `<div class="go-item-value go-white">${high}</div>`,
        // blank line under High Score number
        `<div class="go-item-blank">&nbsp;</div>`,
        `<div class="go-item-label">Captures</div>`,
        `<div class="go-item-value">${captures}</div>`,
        `<div class="go-item-label go-white">Most Captures</div>`,
        `<div class="go-item-value go-white">${mostCaptures}</div>`
      ].join('');

      card.setAttribute('aria-hidden', 'false');
      $modal.classList.add('show');
    }

    function endGame(){
      gameOver = true;
      inGameOverSequence = false;
      updateStatsOnGameEnd(score, captures);
      showGameOverCard();
    }
    function hideModal(){ 
      const card = document.getElementById('goCard');
      if (card) card.setAttribute('aria-hidden', 'true');
      $modal.classList.remove("show"); 
    }

    function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
    function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    function shuffleCopy(a){ const b = a.slice(); shuffle(b); return b; }
    function countBlackPieces(){
      let n = 0;
      for (let r=0;r<BOARD_ROWS;r++){
        for (let c=0;c<BOARD_COLS;c++){
          const p = board[r][c];
          if (p && p.color === BLACK) n++;
        }
      }
      return n;
    }
    function isSquareAttackedByBlackOnBoard(b, r, c){
      for (let rr=0; rr<BOARD_ROWS; rr++){
        for (let cc=0; cc<BOARD_COLS; cc++){
          const p = b[rr][cc]; if (!p || p.color !== BLACK) continue;
          if (blackAttacksSquareOnBoard(p.type, rr, cc, r, c, b)) return true;
        }
      }
      return false;
    }
    function blackAttacksSquareOnBoard(type, br, bc, tr, tc, b){
      const dr = tr - br, dc = tc - bc;
      if (type === "p"){ return (tr === br - 1) && (tc === bc - 1 || tc === bc + 1); }
      if (type === "k"){ return Math.max(Math.abs(dr), Math.abs(dc)) === 1; }
      if (type === "n"){ return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2); }
      if (type === "b" || type === "r" || type === "q"){
        const dirs = [];
        if (type !== "r") dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        if (type !== "b") dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [drr,dcc] of dirs){
          let rr=br+drr, cc=bc+dcc;
          while (inBounds(rr, cc)){
            if (rr === tr && cc === tc) return true;
            const occ = b[rr][cc]; if (occ) break;
            rr += drr; cc += dcc;
          }
        }
        return false;
      }
      return false;
    }
  </script>
</body>
        </html>
