<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ChessRun</title>
  <!-- Boogaloo font for all text -->
  <link href="https://fonts.googleapis.com/css2?family=Boogaloo&display=swap" rel="stylesheet">
  <style>
    :root{
      --board-cols: 8;
      --board-rows: 11;
      --square-size: calc(100vw / var(--board-cols));
      --light: #ffffff;  /* board light squares: white */
      --dark:  #000000;  /* board dark squares: black */
      --text:  #D4AF37;
      --danger: #D32F2F; /* killer highlight is RED now */

      --above-gap: 10px;
      --below-gap: calc(var(--above-gap) * 2);

      /* Slow, smooth scroll duration for advancing */
      --advance-duration: 2400ms;
    }

    html,body{
      margin:0; padding:0; background:var(--dark); color:var(--text);
      font-family: "Boogaloo", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      touch-action: none;
    }

    .wrap{
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
      min-height:100vh; gap:var(--above-gap); padding:10px 0 24px;
      background:var(--dark);
    }

    /* HUD: captures | score | high */
    .hud{
      width:100vw;
      display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;
      padding:0 8px; box-sizing:border-box; gap:0;
      color:var(--text);
    }
    .captures, .score, .high{
      font-weight:700; letter-spacing:0.3px;
      font-size: clamp(18px, 5vw, 22px);
      line-height:1;
    }
    .captures{ justify-self:start; text-align:left; color: #D4AF37; }
    .score{    justify-self:center; text-align:center; font-size: clamp(54px, 15vw, 66px); }
    .high{     justify-self:end; text-align:right; color: #D4AF37; }

    .board-shell{
      position:relative;
      width:100vw; height:calc(var(--square-size) * var(--board-rows));
      max-width:100vw; max-height:95vh;
      border-radius:0; box-shadow:none; background:var(--dark);
      overflow:hidden;
    }
    .board{
      position:absolute; inset:0;
      display:grid; grid-template-columns: repeat(var(--board-cols), 1fr);
      grid-template-rows: repeat(var(--board-rows), 1fr);
      width:100%; height:100%;
    }

    /* Single-strip scroller */
    .strip-scroller{
      position:absolute; left:0; width:100%;
      transform: translateY(0);
      pointer-events:none;
      will-change: transform;
      z-index:5;
    }
    .strip-scroller.transition{
      transition: transform var(--advance-duration) cubic-bezier(0.22, 0.61, 0.2, 1);
    }
    .strip-part{
      position:relative; width:100%;
    }
    .strip-grid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(var(--board-cols), 1fr);
      width:100%; height:100%;
    }

    .sq{
      position:relative;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
      transition: transform 120ms ease;
      font-size: calc(var(--square-size) * 0.6);
      line-height:1;
      font-family: "Boogaloo", system-ui;
    }
    .sq:active{ transform: scale(0.98); }

    .light{ background: var(--light); }
    .dark{  background: var(--dark); }

    /* Piece visuals: user (white) rich royal gold, opponent (black) rich bold blue */
    .piece{ position:relative; z-index:2; font-family: "Boogaloo", system-ui; }
    .white{ color:#D4AF37; text-shadow:none; }  /* royal gold (slightly darker, still bright) */
    .black{ color:#1976D2; text-shadow:none; }  /* rich bold blue (slightly darker, still bright) */
    .danger{ color: var(--danger) !important; } /* killer highlight is RED now */
    .piece svg{ width:calc(var(--square-size) * 0.7); height:calc(var(--square-size) * 0.7); }

    /* Under-board controls */
    .controls{
      width:100vw;
      display:flex; justify-content:space-between; align-items:center;
      gap:20px; padding:0 18px; box-sizing:border-box;
      margin-top: 0;
      font-family: "Boogaloo", system-ui;
    }
    .controls button{
      background: transparent; border:none; padding:10px 0;
      color: #ffffff; font-weight:700; font-size: clamp(18px, 5vw, 22px);
      cursor:pointer; font-family: "Boogaloo", system-ui;
    }
    .controls button:active{ opacity:0.8; }

    /* Modal */
    /* Modal overlay: keep screen visible; do not darken; allow buttons below to work */
    .modal{ position:fixed; inset:0; display:none; z-index:60; background: transparent; pointer-events:none; }
    .modal.show{ display:block; }

    /* Game Over card over the board */
    .go-card{
      position: fixed; /* positioned via JS relative to board */
      background: #000000; /* black */
      border-radius: 18px;
      color: #D4AF37; /* gold text */
      box-sizing: border-box;
      /* gold accent line all the way around */
      border: 4px solid #D4AF37;
      padding: 16px 20px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 10px; /* even spacing between items */
      pointer-events: none; /* tapping does nothing */
      font-family: "Boogaloo", system-ui;
    }
    .go-item-label{ font-size: clamp(18px, 5vw, 22px); font-weight: 800; }
    .go-item-value{ font-size: clamp(18px, 5vw, 22px); font-weight: 800; }
    /* White text utility for specific GO items */
    .go-white{ color:#FFFFFF; }
    /* Blank line spacing under High Score number */
    .go-item-blank{ font-size: clamp(18px, 5vw, 22px); line-height:1; }

    /* Menu overlay: big diagonal squares, no inner lines (inherits black/white) */
    .menu{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:70; }
    .menu.show{ display:flex; align-items:flex-start; justify-content:center; }
    .menu::before{
      content:"";
      position:absolute; inset:0;
      background: #000000;
    }
    .menu-content{
      position:relative; z-index:1;
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
      gap:24px; text-align:center; color:#000000; font-family: "Boogaloo", system-ui;
      padding-top: 0;
    }
    .menu-title{
      font-size: clamp(32px, 10vw, 64px);
      font-weight: 900;
      letter-spacing: 1px;
      text-shadow: 0 2px 0 rgba(0,0,0,0.05);
      font-family: "Boogaloo", system-ui;
      color: #D4AF37;
    }
    .menu-logo{
      display:block;
      width: 70vw;            /* large, but leaves big horizontal gaps */
      max-height: 45vh;       /* most of the top half of screen */
      height: auto;
      object-fit: contain;
      margin-top: calc((100vw - 70vw) / 2);  /* top gap equals side gaps */
      margin-bottom: 2vh;
      margin-left: auto;
      margin-right: auto;
      pointer-events: none;   /* decorative */
    }
    .play-btn{
      position: relative;
      width: min(220px, 50vw);
      height: 48px;
      padding: 14px 28px; border-radius:14px; border:none; cursor:pointer;
      font-size: clamp(18px, 5vw, 22px); font-weight:800;
      color: #000000; font-family: "Boogaloo", system-ui;
      background: #D4AF37;
      box-shadow: none;
    }
    .play-btn::after{
      content: "";
      position: absolute;
      inset: 6px;
      border: 2px solid #000000;
      border-radius: 10px;
      pointer-events: none;
    }
    .play-btn:active{ transform: translateY(1px); box-shadow: none; }

    /* Stats overlay - bottom sheet */
    :root{
      --accent-w: 4px;        /* gold line thickness */
      --accent-gap: 8px;      /* black edge spacing (equal to line offset) */
      --sheet-radius: 18px;
    }
    
    .stats{ position:fixed; inset:0; display:none; z-index:75; }
    .stats.show{ display:block; }
    .stats-backdrop{ position:fixed; top:0; left:0; right:0; height:50vh; background: transparent; }
    .stats-sheet{
      position:fixed; left:0; right:0; bottom:0; height:50vh; background:#000; color: var(--text);
      border-top-left-radius: var(--sheet-radius); border-top-right-radius: var(--sheet-radius);
      border: var(--accent-w) solid #D4AF37; /* move gold accent to outer edge */
      border-bottom: none; /* keep bottom edge without gold line */
    }
    /* Remove inner border; keep content spacing */
    .stats-inner{
      position:absolute;
      top: var(--accent-gap); left: var(--accent-gap); right: var(--accent-gap); bottom: 0;
      border: none; /* no inner border now */
      border-top-left-radius: var(--sheet-radius); border-top-right-radius: var(--sheet-radius);
      padding: 12px 16px; /* inner padding so title doesn't overlap the top accent */
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
    }

    /* Typography and spacing: slightly larger than before, uniform rows */
    .stats-title{ font-size: clamp(16px, 4.5vw, 20px); font-weight:800; text-align:center; line-height: 1; }
    .stats-list{ width:100%; display:flex; flex-direction:column; gap:8px; }
    .stat-row{ display:flex; justify-content:space-between; font-size: clamp(16px, 4.5vw, 20px); line-height: 1; }
    /* Equal spacing above first stat and below last stat using symmetric spacers */
    .stats-spacer{ height: 2em; flex: 0 0 auto; }
    
    /* Alternating colors for stat rows */
    .stat-row.white{ color:#FFFFFF; }
    .stat-row.gold{  color:#D4AF37; }
    
    /* Empty line between stat rows */
    .stat-empty{ height: 1em; line-height:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="captures" class="captures">0</div>
      <div id="score" class="score">0</div>
      <div id="high" class="high">0</div>
    </div>

    <div class="board-shell">
      <div id="board" class="board" aria-label="ChessRun board"></div>
    </div>

    <div class="controls">
      <button id="menuBtn" type="button">Menu</button>
      <button id="restartBtn" type="button">Restart</button>
    </div>
  </div>

  <!-- Menu overlay -->
  <div id="menu" class="menu" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
    <div class="menu-content">
      <img id="menuTitle" class="menu-logo" src="data:image/png;base64,PASTE BASE64 STRING HERE" alt="Chess Run logo" />
      <button id="playBtn" class="play-btn" type="button">Start</button>
      <button id="statsBtn" class="play-btn" type="button">Stats</button>
    </div>
  </div>

  <div id="stats" class="stats" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
    <div id="statsBackdrop" class="stats-backdrop" aria-hidden="true"></div>
    <div id="statsSheet" class="stats-sheet">
      <div class="stats-inner">
        <div id="statsTitle" class="stats-title">Stats</div>
        <div class="stats-spacer"></div>
        <div class="stats-list">
          <div class="stat-row white"><span>Total Games</span><span id="statTotalGames">0</span></div>
          <div class="stat-empty"></div>
          <div class="stat-row gold"><span>High Score</span><span id="statHigh">0</span></div>
          <div class="stat-empty"></div>
          <div class="stat-row white"><span>Total Score</span><span id="statTotalScore">0</span></div>
          <div class="stat-empty"></div>
          <div class="stat-row gold"><span>Average Score</span><span id="statAvgScore">0</span></div>
          <div class="stat-empty"></div>
          <div class="stat-row white"><span>Most Captures</span><span id="statMostTakes">0</span></div>
          <div class="stat-empty"></div>
          <div class="stat-row gold"><span>Total Captures</span><span id="statTotalTakes">0</span></div>
          <div class="stat-empty"></div>
          <div class="stat-row white"><span>Average Captures</span><span id="statAvgTakes">0</span></div>
        </div>
        <div class="stats-spacer"></div>
      </div>
    </div>
  </div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div id="goCard" class="go-card" aria-hidden="true"></div>
  </div>

  <script>
    const BOARD_ROWS = 11;
    const BOARD_COLS = 8;
    const TOP_ROW = BOARD_ROWS - 1;
    const WHITE = "W", BLACK = "B";

    const PROGRESSION = [
      {score: 0,   type: "P"},
      {score: 20,  type: "K"},
      {score: 50,  type: "N"},
      {score: 100, type: "B"},
      {score: 200, type: "R"},
      {score: 300, type: "Q"}
    ];

    // Board-based progression configuration
    const PIECE_ORDER = ["P", "K", "N", "B", "R", "Q"];
    const BOARD_TARGETS = { P:2, K:3, N:4, B:5, R:6, Q:7 };

    // White uses black-piece glyphs but colored via CSS; pawn uses SVG
    const WHITE_SYM = { K:"♚", N:"♞", B:"♝", R:"♜", Q:"♛" };
    const BLACK_SYM = { k:"♚", n:"♞", b:"♝", r:"♜", q:"♛" };

    let board = createEmptyBoard();
    let player = { row: 0, col: 0, type: "P" };

    let score = 0;
    let maxRowReached = 0;
    let high = 0;
    let gameOver = false;
    let inGameOverSequence = false;
    let isAdvancing = false; // lock during scroll
    let waitingForDeathTap = false;
    let killerInfo = null; // { row, col, type }
    let captures = 0;
    let boardsInCurrentStage = 0;

    // Set of immutable black pieces (including mandatory rooks and event pieces)
    let mandatoryRookKeys = new Set();

    let dragging = false;
    let dragEl = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let legalTargets = new Set();

    const $boardShell = document.querySelector(".board-shell");
    const $board = document.getElementById("board");
    const $score = document.getElementById("score");
    const $high  = document.getElementById("high");
    const $cap   = document.getElementById("captures");
    const $modal = document.getElementById("modal");
    const $menu  = document.getElementById("menu");

    const STAGE_INDEX = { P:0, K:1, N:2, B:3, R:4, Q:5 };

    const OPP_WEIGHTS = {
      near: [
        { p:0.38, k:0.24, n:0.20, b:0.10, r:0.07, q:0.01 }, // Pawn
        { p:0.34, k:0.22, n:0.20, b:0.12, r:0.08, q:0.04 }, // King
        { p:0.30, k:0.20, n:0.18, b:0.15, r:0.12, q:0.05 }, // Knight
        { p:0.26, k:0.18, n:0.16, b:0.18, r:0.16, q:0.06 }, // Bishop
        { p:0.22, k:0.16, n:0.16, b:0.20, r:0.18, q:0.08 }, // Rook
        { p:0.18, k:0.14, n:0.14, b:0.22, r:0.20, q:0.12 }, // Queen
      ],
      far: [
        { p:0.34, k:0.22, n:0.18, b:0.12, r:0.10, q:0.04 }, // Pawn
        { p:0.30, k:0.20, n:0.18, b:0.16, r:0.14, q:0.02 }, // King
        { p:0.28, k:0.18, n:0.16, b:0.18, r:0.16, q:0.04 }, // Knight
        { p:0.24, k:0.16, n:0.15, b:0.20, r:0.18, q:0.07 }, // Bishop
        { p:0.22, k:0.14, n:0.14, b:0.22, r:0.20, q:0.08 }, // Rook
        { p:0.18, k:0.12, n:0.12, b:0.24, r:0.22, q:0.12 }, // Queen
      ]
    };

    const OPP_COUNTS = [
      [10, 16],   // Pawn
      [12, 18],   // King
      [14, 20],   // Knight
      [15, 22],   // Bishop
      [16, 24],   // Rook
      [18, 26],   // Queen
    ];

    const CONSTRICTION = [0.35, 0.5, 0.6, 0.7, 0.8, 0.85];

    function currentStage(){ return STAGE_INDEX[player.type] ?? 0; }

    function nextPiece(type){
      const i = PIECE_ORDER.indexOf(type);
      return PIECE_ORDER[(i + 1) % PIECE_ORDER.length];
    }

    function pickByWeights(weights){
      let r = Math.random();
      for (const t of ["p","k","n","b","r","q"]){
        const w = weights[t] || 0;
        if ((r -= w) <= 0) return t;
      }
      return "p";
    }
    function pickFromSubset(weights, subset){
      const total = subset.reduce((s,t)=>s+(weights[t]||0),0) || 1;
      let r = Math.random() * total;
      for (const t of subset){
        const w = weights[t] || 0;
        if ((r -= w) <= 0) return t;
      }
      return subset[0];
    }

    // Stats tracking
    function loadStats(){
      const totalGames = parseInt(localStorage.getItem("chessrun-total-games")||"0",10);
      const totalScore = parseInt(localStorage.getItem("chessrun-total-score")||"0",10);
      const totalTakes = parseInt(localStorage.getItem("chessrun-total-takes")||"0",10);
      const mostTakes  = parseInt(localStorage.getItem("chessrun-most-takes")||"0",10);
      const highScore  = parseInt(localStorage.getItem("chessrun-highscore")||"0",10);
      const avgScore = totalGames ? Math.round(totalScore / totalGames) : 0;
      const avgTakes = totalGames ? Math.round(totalTakes / totalGames) : 0;
      return { totalGames, totalScore, totalTakes, mostTakes, highScore, avgScore, avgTakes };
    }
    function updateStatsOnGameEnd(finalScore, finalTakes){
      const s = loadStats();
      const totalGames = s.totalGames + 1;
      const totalScore = s.totalScore + (finalScore||0);
      const totalTakes = s.totalTakes + (finalTakes||0);
      const mostTakes  = Math.max(s.mostTakes, (finalTakes||0));
      const highScore  = Math.max(s.highScore, (finalScore||0));
      localStorage.setItem("chessrun-total-games", String(totalGames));
      localStorage.setItem("chessrun-total-score", String(totalScore));
      localStorage.setItem("chessrun-total-takes", String(totalTakes));
      localStorage.setItem("chessrun-most-takes", String(mostTakes));
      localStorage.setItem("chessrun-highscore", String(highScore));
    }
    function renderStats(){
      const s = loadStats();
      document.getElementById("statTotalGames").textContent = String(s.totalGames);
      document.getElementById("statHigh").textContent = String(s.highScore);
      document.getElementById("statTotalScore").textContent = String(s.totalScore);
      document.getElementById("statAvgScore").textContent = String(s.avgScore);
      document.getElementById("statMostTakes").textContent = String(s.mostTakes);
      document.getElementById("statTotalTakes").textContent = String(s.totalTakes);
      document.getElementById("statAvgTakes").textContent = String(s.avgTakes);
    }
    function showStats(){ renderStats(); document.getElementById("stats").classList.add("show"); }
    function hideStats(){ document.getElementById("stats").classList.remove("show"); }

    // Init
    init();
    function init(){
      high = parseInt(localStorage.getItem("chessrun-highscore") || "0", 10);
      updateHigh();
      resetBoardForNewGame();
      renderBoard();

      document.getElementById("restartBtn").addEventListener("click", restart);
      document.getElementById("menuBtn").addEventListener("click", showMenu);
      document.getElementById("playBtn").addEventListener("click", hideMenu);
      document.getElementById("statsBtn").addEventListener("click", showStats);
      document.getElementById("statsBackdrop").addEventListener("click", hideStats);
      document.getElementById("statsSheet").addEventListener("click", function(e){ e.stopPropagation(); });

      // Tap-to-move
      $board.addEventListener("click", onBoardClick);

      // Show menu initially
      showMenu();
    }
    function restart(){
      hideModal();
      captures = 0; updateCaptures();
      score = 0;
      maxRowReached = 0;
      player.type = "P";
      gameOver = false;
      inGameOverSequence = false;
      waitingForDeathTap = false; // clear waiting state
      killerInfo = null;
      isAdvancing = false;
      boardsInCurrentStage = 0;
      resetBoardForNewGame();
      renderBoard();
      updateScore();
    }

    // Menu helpers
    function showMenu(){ $menu.classList.add("show"); }
    function hideMenu(){ $menu.classList.remove("show"); }

    // Board helpers
    function createEmptyBoard(){
      return Array.from({length: BOARD_ROWS}, () =>
        Array.from({length: BOARD_COLS}, () => null)
      );
    }
    function cloneBoard(src){
      return src.map(row => row.map(cell => {
        if (!cell) return null;
        const { color, type, highlight } = cell;
        return { color, type, highlight: !!highlight };
      }));
    }
    function placePiece(r, c, piece){ board[r][c] = piece ? { color: piece.color, type: piece.type, highlight: !!piece.highlight } : null; }
    function inBounds(r, c){ return r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS; }
    function keyOf(r, c){ return r + "," + c; }
    function isBlackAt(r,c){ const p = board[r][c]; return p && p.color === BLACK; }
    function isEmpty(r,c){ return inBounds(r,c) && !board[r][c]; }

    // New game setup
    function resetBoardForNewGame(){
      let tries = 0;
      while (tries < 80){
        board = createEmptyBoard();
        player.col = chooseSafeStartingColumn();
        player.row = 0;
        maxRowReached = 0;
        placePiece(player.row, player.col, { color: WHITE, type: player.type });

        if (generateValidSegment()) break;
        tries++;
      }
      updateScore();
      updateCaptures();
    }

    function chooseSafeStartingColumn(){
      const cols = Array.from({length: BOARD_COLS}, (_,i)=>i);
      shuffle(cols);
      return cols[0];
    }

    // --------------------- Generation with validation ---------------------
    function generateValidSegment(){
      mandatoryRookKeys = new Set();
      generatePuzzleSegment();
      guardStartSquare();

      if (!hasSafeFirstMoveFromStart()){
        return false;
      }

      if (!constrictAlternatesUsingPath()) return false;

      const res = bfsSafePath(board, player.type);
      return !!(res && res.path && res.path.length);
    }

    function hasSafeFirstMoveFromStart(){
      const moves = getLegalMoves(player.type, player.row, player.col);
      for (const mv of moves){
        if (!isSquareAttackedByBlack(mv.toRow, mv.toCol)){
          return true;
        }
      }
      return false;
    }

    function generatePuzzleSegment(){
      let attempts = 0;
      const stage = currentStage();
      const [minOpp, maxOpp] = OPP_COUNTS[stage];

      while (attempts < 30){
        const savedCol = player.col;
        board = createEmptyBoard();
        player.row = 0; player.col = savedCol;
        maxRowReached = 0;
        placePiece(player.row, player.col, { color: WHITE, type: player.type });
        mandatoryRookKeys = new Set();

        const protectedSquares = new Set();
        const ok = buildTruthPathWithForcedSwitch(protectedSquares);
        if (!ok){ attempts++; continue; }

        if (player.type === "P"){
          const successTwo = ensureTwoPawnDecisionEvents(protectedSquares);
          if (!successTwo){ attempts++; continue; }
        }

        const targetOpp = randInt(minOpp, maxOpp);
        placeOppositionWithConstraints(targetOpp, protectedSquares);

        if (player.type === "P"){
          restrictFirstOppositionInAdjacentColumns(protectedSquares);
          enforceMandatoryAdjacentRook(protectedSquares);
        }

        const res = bfsSafePath(board, player.type);
        if (res && res.path && res.path.length){
          enforceOppositionCountRange(minOpp, maxOpp, protectedSquares);
          const res2 = bfsSafePath(board, player.type);
          if (res2 && res2.path && res2.path.length) return;
        }

        repairEarlyRows(protectedSquares);
        enforceOppositionCountRange(minOpp, maxOpp, protectedSquares);
        attempts++;
      }

      for (let r=1;r<=3;r++){ board[r][player.col] = null; guardSquareFromAttackWithImmutables(r, player.col, mandatoryRookKeys); }
      placeOppositionWithConstraints(randInt(minOpp, maxOpp), new Set());
      if (player.type === "P"){
        enforceMandatoryAdjacentRook(new Set());
        ensureTwoPawnDecisionEvents(new Set());
      }
      enforceOppositionCountRange(minOpp, maxOpp, new Set());
    }

    function buildTruthPathWithForcedSwitch(protectedSquares){
      let r = 0, c = player.col;

      const f1 = r + 1, f2 = r + 2;
      let firstAdvance = 1;
      if (inBounds(f2,c) && isEmpty(f1,c) && isEmpty(f2,c) && landingSafeAfterSimulatedMove(r,c,f2,c)){
        firstAdvance = (Math.random() < 0.35) ? 2 : 1;
      }
      for (let k=1;k<=firstAdvance;k++){
        board[r+k][c] = null;
        protectedSquares.add(keyOf(r+k,c));
        guardSquareFromAttackWithImmutables(r+k,c, mandatoryRookKeys);
      }
      r += firstAdvance;

      const switchRow = randInt(2, Math.min(7, TOP_ROW-2));
      let didSwitch = false;

      while (r < TOP_ROW){
        const nextR = r + 1;

        if (nextR === switchRow){
          const dir = (c === 0) ? +1 : (c === BOARD_COLS-1) ? -1 : (Math.random() < 0.5 ? -1 : +1);
          const targetC = c + dir;

          board[nextR][c] = { color: BLACK, type: "p" };
          const stage = currentStage();
          const nearWeights = OPP_WEIGHTS.near[stage];
          const targetType = pickFromSubset(nearWeights, ["n","r","b"]);
          board[nextR][targetC] = { color: BLACK, type: targetType };
          pruneAttackersForCaptureLanding(r, c, nextR, targetC);
          if (!landingSafeAfterSimulatedCapture(r, c, nextR, targetC)){
            board[nextR][c] = null;
            const altC = c - dir;
            if (inBounds(nextR, altC)){
              const altType = pickFromSubset(nearWeights, ["n","r","b"]);
              board[nextR][altC] = { color: BLACK, type: altType };
              pruneAttackersForCaptureLanding(r, c, nextR, altC);
              if (!landingSafeAfterSimulatedCapture(r, c, nextR, altC)) return false;
              protectedSquares.add(keyOf(nextR, altC));
              r = nextR; c = altC; didSwitch = true; continue;
            } else { return false; }
          }
          protectedSquares.add(keyOf(nextR, targetC));
          r = nextR; c = targetC; didSwitch = true; continue;
        }

        let moved = false;
        if (isEmpty(nextR, c) && landingSafeAfterSimulatedMove(r, c, nextR, c)){
          board[nextR][c] = null;
          protectedSquares.add(keyOf(nextR, c));
          guardSquareFromAttackWithImmutables(nextR, c, mandatoryRookKeys);
          r = nextR; moved = true;
        }
        if (!moved){
          const preferred = (Math.random() < 0.5 ? -1 : +1);
          const ordered = [preferred, preferred === -1 ? +1 : -1];
          for (const dc of ordered){
            const targetC = c + dc;
            if (!inBounds(nextR, targetC)) continue;
            if (!board[nextR][targetC]){
              const stage = currentStage();
              const nearWeights = OPP_WEIGHTS.near[stage];
              const tType = pickFromSubset(nearWeights, ["n","r","b"]);
              board[nextR][targetC] = { color: BLACK, type: tType };
            }
            pruneAttackersForCaptureLanding(r, c, nextR, targetC);
            if (landingSafeAfterSimulatedCapture(r, c, nextR, targetC)){
              protectedSquares.add(keyOf(nextR, targetC));
              r = nextR; c = targetC; moved = true; break;
            } else {
              board[nextR][targetC] = null;
            }
          }
        }
        if (!moved){
          board[nextR][c] = null;
          protectedSquares.add(keyOf(nextR, c));
          guardSquareFromAttackWithImmutables(nextR, c, mandatoryRookKeys);
          r = nextR;
        }
      }
      return didSwitch;
    }

    function ensureTwoPawnDecisionEvents(protectedSquares){
      if (player.type !== "P") return true;

      const pathRes = bfsSafePath(board, player.type);
      if (!pathRes || !pathRes.path || pathRes.path.length < 2) return false;

      const steps = [];
      for (let i = 1; i < pathRes.path.length; i++){
        const prev = pathRes.path[i-1];
        const curr = pathRes.path[i];
        if (curr.r === prev.r + 1 && curr.c === prev.c && curr.r < TOP_ROW){
          steps.push({prev, curr});
        }
      }
      if (steps.length < 2) return false;

      let added = 0;
      const usedRowCol = new Set();

      for (const step of steps){
        if (added >= 2) break;
        const { prev, curr } = step;
        const keyStep = keyOf(curr.r, curr.c);
        if (usedRowCol.has(keyStep)) continue;

        const dirs = shuffleCopy([-1, +1]);
        for (const dc of dirs){
          const targetC = curr.c + dc;
          if (!inBounds(curr.r, targetC)) continue;

          const eventKey = keyOf(curr.r, targetC);
          let created = false;
          if (!board[curr.r][targetC]){
            const stage = currentStage();
            const nearWeights = OPP_WEIGHTS.near[stage];
            const tType = pickFromSubset(nearWeights, ["n","r","b","p","k"]);
            board[curr.r][targetC] = { color: BLACK, type: tType };
            created = true;
          }

          pruneAttackersForCaptureLanding(prev.r, prev.c, curr.r, targetC);
          if (!landingSafeAfterSimulatedCapture(prev.r, prev.c, curr.r, targetC)){
            if (created && !protectedSquares.has(eventKey)) board[curr.r][targetC] = null;
            continue;
          }

          // Validate solvability after capture choice
          const savedPlayer = { ...player };
          const tempBoard = cloneBoard(board);
          tempBoard[prev.r][prev.c] = null;
          tempBoard[curr.r][targetC] = { color: WHITE, type: "P" };
          player.row = curr.r; player.col = targetC;
          const captureRes = bfsSafePath(tempBoard, player.type);
          player = savedPlayer;
          if (!captureRes || !captureRes.path || captureRes.path.length === 0){
            if (created && !protectedSquares.has(eventKey)) board[curr.r][targetC] = null;
            continue;
          }

          protectedSquares.add(eventKey);
          mandatoryRookKeys.add(eventKey);
          usedRowCol.add(keyStep);
          added++;
          break;
        }
      }

      return added === 2;
    }

    function placeOppositionWithConstraints(targetCount, protectedSquares){
      const forbidden = new Set(protectedSquares);
      let current = countBlackPieces();

      const near = collectOppCandidates(forbidden, "near");
      current += placeOppFromCandidates(near, targetCount - current, forbidden);

      if (current < targetCount){
        const far = collectOppCandidates(forbidden, "far");
        current += placeOppFromCandidates(far, targetCount - current, forbidden);
      }

      // Safety cleanup: remove any black pieces that ended up on TOP_ROW
      for (let c = 0; c < BOARD_COLS; c++){
        const p = board[TOP_ROW][c];
        if (p && p.color === BLACK){
          board[TOP_ROW][c] = null;
        }
      }

      while (countBlackPieces() > targetCount){
        const list = [];
        for (let r=1;r<=TOP_ROW;r++){
          for (let c=0;c<BOARD_COLS;c++){
            const p = board[r][c];
            const k = keyOf(r,c);
            if (p && p.color === BLACK && !forbidden.has(k) && !mandatoryRookKeys.has(k)){
              list.push({r,c, d: Math.abs(c - player.col) + Math.abs(r - 0)});
            }
          }
        }
        if (!list.length) break;
        list.sort((a,b)=>b.d - a.d);
        const rem = list[0];
        board[rem.r][rem.c] = null;
      }
    }

    function collectOppCandidates(forbidden, bias){
      const cand = [];
      for (let r=1;r<=TOP_ROW-1;r++){
        for (let c=0;c<BOARD_COLS;c++){
          if (board[r][c]) continue;
          const k = keyOf(r,c);
          if (forbidden.has(k)) continue;
          const nearLane = Math.abs(c - player.col) <= 1;
          if ((bias === "near" && nearLane) || (bias === "far" && !nearLane)){
            cand.push({r,c,bias});
          }
        }
      }
      shuffle(cand);
      return cand;
    }

    function placeOppFromCandidates(candidates, need, forbidden){
      let placed = 0;
      for (const cand of candidates){
        if (placed >= need) break;
        if (board[cand.r][cand.c]) continue;
        const stage = currentStage();
        const weights = OPP_WEIGHTS[cand.bias][stage];
        const type = pickByWeights(weights);
        board[cand.r][cand.c] = { color: BLACK, type };
        if (attacksAnyProtected(cand.r, cand.c, type, forbidden)){
          board[cand.r][cand.c] = null;
          continue;
        }
        placed++;
      }
      return placed;
    }

    function restrictFirstOppositionInAdjacentColumns(protectedSquares){
      for (const dc of [-1, +1]){
        const col = player.col + dc;
        if (!inBounds(1, col)) continue;
        let firstRow = -1;
        for (let r = 1; r <= TOP_ROW; r++){
          const p = board[r][col];
          if (p && p.color === BLACK){ firstRow = r; break; }
        }
        if (firstRow === -1) continue;
        const p = board[firstRow][col];
        if (p.type !== "n" && p.type !== "r"){
          board[firstRow][col] = { color: BLACK, type: (Math.random()<0.5?"n":"r") };
        }
        const type = board[firstRow][col].type;
        if (attacksAnyProtected(firstRow, col, type, protectedSquares)){
          let moved = false;
          for (let rr = firstRow + 1; rr <= TOP_ROW - 1; rr++){
            if (!board[rr][col]){
              board[rr][col] = { color: BLACK, type };
              board[firstRow][col] = null;
              if (!attacksAnyProtected(rr, col, type, protectedSquares)){
                moved = true; break;
              } else {
                board[firstRow][col] = { color: BLACK, type };
                board[rr][col] = null;
              }
            }
          }
          if (!moved) board[firstRow][col] = null;
        }
      }
    }

    function enforceMandatoryAdjacentRook(protectedSquares){
      let obstacleRow = -1;
      for (let r=1; r<=TOP_ROW; r++){
        const p = board[r][player.col];
        if (p && p.color === BLACK){ obstacleRow = r; break; }
      }
      if (obstacleRow === -1) obstacleRow = 1;

      const candidates = [];
      if (player.col - 1 >= 0){
        for (let r=1; r<=obstacleRow; r++){
          if (!board[r][player.col - 1]) candidates.push({r, c: player.col - 1});
        }
      }
      if (player.col + 1 < BOARD_COLS){
        for (let r=1; r<=obstacleRow; r++){
          if (!board[r][player.col + 1]) candidates.push({r, c: player.col + 1});
        }
      }
      shuffle(candidates);

      let placed = false;
      for (const cand of candidates){
        board[cand.r][cand.c] = { color: BLACK, type: "r" };
        const k = keyOf(cand.r, cand.c);
        mandatoryRookKeys.add(k);

        if (attacksAnyProtected(cand.r, cand.c, "r", protectedSquares)){
          let moved = false;
          for (let rr = cand.r; rr >= 1; rr--){
            if (!board[rr][cand.c]){
              board[rr][cand.c] = { color: BLACK, type: "r" };
              board[cand.r][cand.c] = null;
              const kk = keyOf(rr, cand.c);
              mandatoryRookKeys.delete(k);
              mandatoryRookKeys.add(kk);
              if (!attacksAnyProtected(rr, cand.c, "r", protectedSquares)){ moved = true; break; }
              board[cand.r][cand.c] = { color: BLACK, type: "r" };
              board[rr][cand.c] = null;
              mandatoryRookKeys.delete(kk);
              mandatoryRookKeys.add(k);
            }
          }
        }

        placed = true; break;
      }

      if (!placed){
        const adjCols = [player.col - 1, player.col + 1].filter(c => c >= 0 && c < BOARD_COLS);
        for (const ac of adjCols){
          for (let r=1; r<=obstacleRow; r++){
            const k = keyOf(r, ac);
            board[r][ac] = { color: BLACK, type: "r" };
            mandatoryRookKeys.add(k);
            placed = true; break;
          }
          if (placed) break;
        }
      }
    }

    function constrictAlternatesUsingPath(){
      const stage = currentStage();
      const [minOpp, maxOpp] = OPP_COUNTS[stage];
      const baseIntensity = CONSTRICTION[stage];

      let intensity = baseIntensity;
      for (let attempt = 0; attempt < 5; attempt++){
        const original = cloneBoard(board);

        const res = bfsSafePath(board, player.type);
        if (!res || !res.path || !res.path.length) return false;

        const pathSet = new Set(res.path.map(p => keyOf(p.r, p.c)));

        for (let r=1; r<=TOP_ROW-1; r++){
          for (let c=0; c<BOARD_COLS; c++){
            const k = keyOf(r,c);
            if (pathSet.has(k)) continue;
            if (board[r][c]) continue;
            if (Math.random() > intensity) continue;

            const bias = (Math.abs(c - player.col) <= 1) ? "near" : "far";
            const weights = OPP_WEIGHTS[bias][stage];
            const t = pickByWeights(weights);

            board[r][c] = { color: BLACK, type: t };
            let attacksPath = false;
            for (const pk of pathSet){
              const [pr, pc] = pk.split(",").map(Number);
              if (blackAttacksSquare(t, r, c, pr, pc)){ attacksPath = true; break; }
            }
            if (attacksPath){ board[r][c] = null; }
          }
        }

        enforceOppositionCountRange(minOpp, maxOpp, pathSet);

        const res2 = bfsSafePath(board, player.type);
        if (res2 && res2.path && res2.path.length){
          return true;
        } else {
          board = original;
          intensity *= 0.8;
        }
      }
      return false;
    }

    function guardStartSquare(){
      guardSquareFromAttackWithImmutables(player.row, player.col, mandatoryRookKeys);
    }

    function repairEarlyRows(protectedSquares){
      const c = player.col;
      for (let r=1; r<=3; r++){
        const forwardOk = isEmpty(r, c) && landingSafeAfterSimulatedMove(r-1, c, r, c);
        const leftOk = (c-1>=0) && isBlackAt(r, c-1) && landingSafeAfterSimulatedCapture(r-1, c, r, c-1);
        const rightOk= (c+1<BOARD_COLS) && isBlackAt(r, c+1) && landingSafeAfterSimulatedCapture(r-1, c, r, c+1);
        if (forwardOk || leftOk || rightOk) continue;

        for (const dc of shuffleCopy([-1,+1])){
          const nc = c + dc; if (!inBounds(r, nc)) continue;
          const stage = currentStage();
          const nearWeights = OPP_WEIGHTS.near[stage];
          const tType = pickFromSubset(nearWeights, ["n","r","b"]);
          board[r][nc] = { color: BLACK, type: tType };
          pruneAttackersForCaptureLanding(r-1, c, r, nc);
          if (landingSafeAfterSimulatedCapture(r-1, c, r, nc)){
            protectedSquares.add(keyOf(r, nc));
            return;
          } else { board[r][nc] = null; }
        }
        board[r][c] = null;
        guardSquareFromAttackWithImmutables(r, c, mandatoryRookKeys);
        protectedSquares.add(keyOf(r, c)); return;
      }
    }

    function enforceOppositionCountRange(min, max, forbidden){
      let count = countBlackPieces();
      if (count < min){
        const need = min - count;
        const extras = collectOppCandidates(forbidden, "far");
        placeOppFromCandidates(extras, need, forbidden);
      }
      while ((count = countBlackPieces()) > max){
        const list = [];
        for (let r=0;r<BOARD_ROWS;r++){
          for (let c=0;c<BOARD_COLS;c++){
            const p = board[r][c];
            const k = keyOf(r,c);
            if (p && p.color === BLACK && !forbidden.has(k) && !mandatoryRookKeys.has(k)){
              list.push({r,c, d: Math.abs(c - player.col) + Math.abs(r - 0)});
            }
          }
        }
        if (!list.length) break;
        list.sort((a,b)=>b.d - a.d);
        const rem = list[0];
        board[rem.r][rem.c] = null;
      }
    }

    // --------------------- Unified BFS: solvable path for current piece ---------------------
    function bfsSafePath(b, type){
      const start = { r: player.row, c: player.col, b: cloneBoard(b) };
      const queue = [start];
      const seen = new Set([stateKeyGeneric(start, type)]);
      const parent = new Map();
      const stateMap = new Map([[stateKeyGeneric(start, type), start]]);

      while (queue.length){
        const s = queue.shift();
        if (s.r === TOP_ROW){ return reconstructPathGeneric(s, parent, stateMap, type); }

        const moves = getMovesOnBoardGeneric(s.b, type, s.r, s.c);
        for (const mv of moves){
          const next = simulateMoveOnBoardGeneric(s, type, mv);
          if (!next) continue;
          const k = stateKeyGeneric(next, type); if (seen.has(k)) continue;
          seen.add(k); parent.set(k, stateKeyGeneric(s, type)); stateMap.set(k, next); queue.push(next);
        }
      }
      return null;
    }
    function reconstructPathGeneric(endState, parent, stateMap, type){
      const path = []; let k = stateKeyGeneric(endState, type);
      while (k){ const st = stateMap.get(k); path.push({ r: st.r, c: st.c }); k = parent.get(k); }
      path.reverse(); return { path };
    }
    function stateKeyGeneric(st, type){ return type + "|" + st.r + "|" + st.c + "|" + hashBoard(st.b); }

    function hashBoard(b){
      let s = "";
      for (let r=0;r<BOARD_ROWS;r++){
        for (let c=0;c<BOARD_COLS;c++){
          const p = b[r][c]; s += (p ? (p.color === BLACK ? p.type : p.type.toLowerCase()) : ".");
        }
      }
      return s;
    }

    function getMovesOnBoardGeneric(b, type, r, c){
      const out = [];
      const add = (rr, cc) => {
        if (!inBounds(rr, cc)) return;
        const dest = b[rr][cc];
        if (!dest || dest.color === BLACK){
          out.push({ toRow: rr, toCol: cc });
        }
      };
      if (type === "P"){
        const f1 = r + 1, f2 = r + 2;
        if (inBounds(f1, c) && !b[f1][c]) add(f1, c);
        if (r === 0 && inBounds(f2, c) && !b[f1][c] && !b[f2][c]) add(f2, c);
        if (inBounds(f1, c-1) && b[f1][c-1] && b[f1][c-1].color === BLACK) add(f1, c-1);
        if (inBounds(f1, c+1) && b[f1][c+1] && b[f1][c+1].color === BLACK) add(f1, c+1);
      } else if (type === "K"){
        for (let dr=-1; dr<=1; dr++){
          for (let dc=-1; dc<=1; dc++){
            if (dr===0 && dc===0) continue;
            add(r+dr, c+dc);
          }
        }
      } else if (type === "N"){
        [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
      } else if (type === "B"){
        rayOnBoard(b, r, c, [[1,1],[1,-1],[-1,1],[-1,-1]], out);
      } else if (type === "R"){
        rayOnBoard(b, r, c, [[1,0],[-1,0],[0,1],[0,-1]], out);
      } else if (type === "Q"){
        rayOnBoard(b, r, c, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], out);
      }
      return out;
    }
    function rayOnBoard(b, r, c, dirs, out){
      for (const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc;
        while (inBounds(rr,cc)){
          const d = b[rr][cc];
          if (!d){ out.push({toRow:rr, toCol:cc}); }
          else { if (d.color===BLACK) out.push({toRow:rr, toCol:cc}); break; }
          rr+=dr; cc+=dc;
        }
      }
    }
    function simulateMoveOnBoardGeneric(state, type, mv){
      const nb = cloneBoard(state.b);
      nb[state.r][state.c] = null; nb[mv.toRow][mv.toCol] = { color: WHITE, type };
      if (isSquareAttackedByBlackOnBoard(nb, mv.toRow, mv.toCol)) return null;
      return { r: mv.toRow, c: mv.toCol, b: nb };
    }

    // --------------------- Attack/defense utilities ---------------------
    function landingSafeAfterSimulatedMove(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC];
      const prevTo   = board[toR][toC];
      board[fromR][fromC] = null;
      board[toR][toC] = { color: WHITE, type: player.type };
      const attacked = isSquareAttackedByBlack(toR, toC);
      board[fromR][fromC] = prevFrom || null;
      board[toR][toC] = prevTo || null;
      return !attacked;
    }
    function landingSafeAfterSimulatedCapture(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC];
      const prevTo   = board[toR][toC];
      board[fromR][fromC] = null;
      board[toR][toC] = { color: WHITE, type: player.type };
      const attacked = isSquareAttackedByBlack(toR, toC);
      board[fromR][fromC] = prevFrom || null;
      board[toR][toC] = prevTo || null;
      return !attacked;
    }
    function pruneAttackersForCaptureLanding(fromR, fromC, toR, toC){
      const prevFrom = board[fromR][fromC];
      const prevTo   = board[toR][toC];
      board[fromR][fromC] = null;
      board[toR][toC] = { color: WHITE, type: player.type };
      let guard = 0;
      while (isSquareAttackedByBlack(toR, toC) && guard < 300){
        const atks = attackersOfSquare(toR, toC);
        if (!atks.length) break;
        atks.sort((a,b)=>((a.row-toR)**2+(a.col-toC)**2)-((b.row-toR)**2+(b.col-toC)**2));
        const kill = atks[0];
        const kk = keyOf(kill.row, kill.col);
        if (!mandatoryRookKeys.has(kk)) board[kill.row][kill.col] = null;
        guard++;
      }
      board[fromR][fromC] = prevFrom || null;
      board[toR][toC] = prevTo || null;
    }

    function isSquareAttackedByBlack(r, c){
      for (let rr = 0; rr < BOARD_ROWS; rr++){
        for (let cc = 0; cc < BOARD_COLS; cc++){
          const p = board[rr][cc];
          if (!p || p.color !== BLACK) continue;
          if (blackAttacksSquare(p.type, rr, cc, r, c)) return true;
        }
      }
      return false;
    }
    function attackersOfSquare(r, c){
      const list = [];
      for (let rr=0; rr<BOARD_ROWS; rr++){
        for (let cc=0; cc<BOARD_COLS; cc++){
          const p = board[rr][cc];
          if (!p || p.color !== BLACK) continue;
          if (blackAttacksSquare(p.type, rr, cc, r, c)) list.push({row: rr, col: cc, type: p.type});
        }
      }
      return list;
    }
    function blackAttacksSquare(type, br, bc, tr, tc){
      const dr = tr - br, dc = tc - bc;
      if (type === "p"){
        return (tr === br - 1) && (tc === bc - 1 || tc === bc + 1);
      }
      if (type === "k"){
        return Math.max(Math.abs(dr), Math.abs(dc)) === 1;
      }
      if (type === "n"){
        return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
      }
      if (type === "b" || type === "r" || type === "q"){
        const dirs = [];
        if (type !== "r") dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        if (type !== "b") dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [drr,dcc] of dirs){
          let rr = br + drr, cc = bc + dcc;
          while (inBounds(rr, cc)){
            if (rr === tr && cc === tc) return true;
            const occ = board[rr][cc];
            if (occ) break;
            rr += drr; cc += dcc;
          }
        }
        return false;
      }
      return false;
    }
    function guardSquareFromAttackWithImmutables(r, c, immutables){
      let guard = 0;
      while (isSquareAttackedByBlack(r, c) && guard < 300){
        const atks = attackersOfSquare(r, c);
        if (!atks.length) break;
        atks.sort((a,b)=>((a.row-r)**2+(a.col-c)**2)-((b.row-r)**2+(b.col-c)**2));
        const kill = atks[0];
        const kk = keyOf(kill.row, kill.col);
        if (!immutables.has(kk)) board[kill.row][kill.col] = null;
        guard++;
      }
    }
    function attacksAnyProtected(br, bc, type, protectedSquares){
      for (const k of protectedSquares){
        const [r,c] = k.split(",").map(Number);
        if (blackAttacksSquare(type, br, bc, r, c)) return true;
      }
      return false;
    }

    // --------------------- Drag-and-drop & Tap UI ---------------------
    function onPointerDown(e){
      if (gameOver || inGameOverSequence || isAdvancing) return;
      const sq = e.target.closest(".sq");
      if (!sq) return;
      const r = parseInt(sq.dataset.row, 10);
      const c = parseInt(sq.dataset.col, 10);
      if (r !== player.row || c !== player.col) return;

      const moves = getLegalMoves(player.type, player.row, player.col);
      legalTargets = new Set(moves.map(m => keyOf(m.toRow, m.toCol)));

      dragging = true;

      dragEl = createPieceVisual({ color: WHITE, type: player.type }, true);
      document.body.appendChild(dragEl);
      const rect = sq.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;

      positionDragEl(e.clientX - dragOffsetX, e.clientY - rect.top, rect.width, rect.height);

      dragEl.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    }

    function onPointerMove(e){
      if (!dragging || !dragEl) return;
      const squareW = $board.getBoundingClientRect().width / BOARD_COLS;
      const squareH = $board.getBoundingClientRect().height / BOARD_ROWS;
      positionDragEl(e.clientX - dragOffsetX, e.clientY - dragOffsetY, squareW, squareH);
    }

    function onPointerUp(e){
      if (!dragging) return;
      dragging = false;

      const drop = pointerToBoardSquare(e.clientX, e.clientY);
      if (drop){
        const k = keyOf(drop.r, drop.c);
        if (legalTargets.has(k)){
          performMove(drop.r, drop.c);
          renderBoard();
        }
      }
      if (dragEl && dragEl.parentNode) dragEl.parentNode.removeChild(dragEl);
      dragEl = null;
    }

    // Tap-to-move
    function onBoardClick(e){
      if (gameOver || dragging || isAdvancing) return;

      // If we're in the game-over sequence and waiting for tap, any board tap triggers death
      if (inGameOverSequence && waitingForDeathTap){
        performDeathCaptureAndScheduleEnd();
        return;
      }

      // Block input during game-over sequence (after death tap, before game over modal)
      if (inGameOverSequence) return;
      const sq = e.target.closest(".sq");
      if (!sq) return;
      const r = parseInt(sq.dataset.row, 10);
      const c = parseInt(sq.dataset.col, 10);
      if (r === player.row && c === player.col) return;

      const moves = getLegalMoves(player.type, player.row, player.col);
      const isLegal = moves.some(m => m.toRow === r && m.toCol === c);
      if (isLegal){
        performMove(r, c);
        renderBoard();
      }
    }

    function positionDragEl(left, top, squareW, squareH){
      dragEl.style.position = "fixed";
      dragEl.style.left = `${left}px`;
      dragEl.style.top  = `${top}px`;
      dragEl.style.width  = `${squareW}px`;
      dragEl.style.height = `${squareH}px`;
      dragEl.style.zIndex = "100";
      dragEl.style.pointerEvents = "none";
    }

    function pointerToBoardSquare(clientX, clientY){
      const rect = $board.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) return null;
      const col = Math.floor(x / (rect.width / BOARD_COLS));
      const uiRow = Math.floor(y / (rect.height / BOARD_ROWS));
      const row = TOP_ROW - uiRow; // top in UI = highest row index
      return { r: row, c: col };
    }

    // --------------------- Gameplay ---------------------
    function performMove(toRow, toCol){
      if (gameOver || inGameOverSequence || isAdvancing) return;

      if (toRow > maxRowReached){
        score += (toRow - maxRowReached);
        maxRowReached = toRow;
        updateScore();
      }

      const dest = board[toRow][toCol];
      if (dest && dest.color === BLACK){
        captures++;
        updateCaptures();
      }

      board[player.row][player.col] = null;
      player.row = toRow; player.col = toCol;
      placePiece(player.row, player.col, { color: WHITE, type: player.type });

      if (isSquareAttackedByBlack(player.row, player.col)){
        revealKillerThenCaptureAndEnd();
        return;
      }

      if (player.row === TOP_ROW){
        boardsInCurrentStage++;
        if (boardsInCurrentStage >= BOARD_TARGETS[player.type]){
          player.type = nextPiece(player.type);
          boardsInCurrentStage = 0;
          placePiece(player.row, player.col, { color: WHITE, type: player.type });
        }
        smoothAdvanceAndRegenerate();
      }
    }

    function buildNextBoardFromCurrentTop(){
      const seed = createEmptyBoard();
      for (let c = 0; c < BOARD_COLS; c++){
        seed[0][c] = board[player.row][c] ? { ...board[player.row][c] } : null;
      }

      const saved = {
        board: board,
        player: { ...player },
        mandatory: new Set(mandatoryRookKeys),
        maxRow: maxRowReached,
      };

      board = seed;
      player.row = 0;
      maxRowReached = 0;
      mandatoryRookKeys = new Set();

      let tries = 0;
      while (tries < 80){
        if (generateValidSegment()) break;
        tries++;
      }
      const nextBoard = cloneBoard(board);

      board = saved.board;
      player = saved.player;
      mandatoryRookKeys = saved.mandatory;
      maxRowReached = saved.maxRow;

      return nextBoard;
    }

    function smoothAdvanceAndRegenerate(){
      isAdvancing = true;

      const prevBoard = cloneBoard(board);
      const nextBoard = buildNextBoardFromCurrentTop();

      const shellRect = $boardShell.getBoundingClientRect();
      const boardHeight = shellRect.height;
      const squareHeight = boardHeight / BOARD_ROWS;
      const incomingRows = BOARD_ROWS - 1;
      const incomingHeight = incomingRows * squareHeight;

      const incomingRowsArray = [];
      for (let r = TOP_ROW; r >= 1; r--) incomingRowsArray.push(nextBoard[r]);

      const currentRowsArray = [];
      for (let r = TOP_ROW; r >= 0; r--) currentRowsArray.push(prevBoard[r]);

      const strip = document.createElement("div");
      strip.className = "strip-scroller";
      strip.style.height = `${incomingHeight + boardHeight}px`;
      strip.style.transform = `translateY(-${incomingHeight}px)`;

      const incomingPart = document.createElement("div");
      incomingPart.className = "strip-part";
      incomingPart.style.height = `${incomingHeight}px`;
      const incomingGrid = renderRowsGrid(incomingRowsArray, TOP_ROW + incomingRows);
      incomingPart.appendChild(incomingGrid);

      const currentPart = document.createElement("div");
      currentPart.className = "strip-part";
      currentPart.style.height = `${boardHeight}px`;
      const currentGrid = renderRowsGrid(currentRowsArray, TOP_ROW);
      currentPart.appendChild(currentGrid);

      strip.appendChild(incomingPart);
      strip.appendChild(currentPart);

      $boardShell.appendChild(strip);
      $board.style.opacity = "0";

      requestAnimationFrame(() => {
        strip.classList.add("transition");
        strip.style.transform = `translateY(0px)`;
      });

      strip.addEventListener("transitionend", () => {
        board = nextBoard;
        player.row = 0;
        maxRowReached = 0;

        renderBoard();
        $board.style.opacity = "1";
        if (strip.parentNode) strip.parentNode.removeChild(strip);

        isAdvancing = false;
      }, { once: true });
    }

    function renderRowsGrid(rowsArray, startV){
      const grid = document.createElement("div");
      grid.className = "strip-grid";
      grid.style.gridTemplateRows = `repeat(${rowsArray.length}, 1fr)`;

      const frag = document.createDocumentFragment();
      for (let i = 0; i < rowsArray.length; i++){
        const vIdx = startV - i;
        const row = rowsArray[i];
        for (let c = 0; c < BOARD_COLS; c++){
          const sq = document.createElement("div");
          sq.className = "sq " + (((vIdx + c) % 2 === 0) ? "light" : "dark");
          const p = row[c];
          if (p){
            const pieceEl = createPieceVisual(p, false);
            sq.appendChild(pieceEl);
          }
          frag.appendChild(sq);
        }
      }
      grid.appendChild(frag);
      return grid;
    }

    function revealKillerThenCaptureAndEnd(){
      inGameOverSequence = true;

      const atks = attackersOfSquare(player.row, player.col);
      if (!atks.length){
        endGame();
        return;
      }
      atks.sort((a,b)=>((a.row-player.row)**2+(a.col-player.col)**2)-((b.row-player.row)**2+(b.col-player.col)**2));
      const killer = atks[0];

      const kp = board[killer.row][killer.col];
      if (kp){ kp.highlight = true; }
      renderBoard();

      // Store killer info and wait for user tap
      killerInfo = { row: killer.row, col: killer.col, type: killer.type };
      waitingForDeathTap = true;
    }

    function performDeathCaptureAndScheduleEnd(){
      // Guard: only proceed if we're actually waiting for death tap and have killer info
      if (!waitingForDeathTap || !killerInfo) return;
      const { row, col, type } = killerInfo;
      const moving = board[row][col] ? { ...board[row][col] } : { color: BLACK, type, highlight: true };
      board[row][col] = null;
      placePiece(player.row, player.col, moving);
      renderBoard();

      waitingForDeathTap = false;
      killerInfo = null;

      setTimeout(() => { endGame(); }, 1000); // 1 second after death
    }

    function updateScore(){
      $score.textContent = String(score);
      if (score > high){
        high = score;
        localStorage.setItem("chessrun-highscore", String(high));
        updateHigh();
      }
    }
    function updateHigh(){ $high.textContent = String(high); }
    function updateCaptures(){ $cap.textContent = String(captures); }

    function applyProgression(){
      let newType = player.type;
      for (let i = PROGRESSION.length - 1; i >= 0; i--){
        if (score >= PROGRESSION[i].score){ newType = PROGRESSION[i].type; break; }
      }
      if (newType !== player.type){
        player.type = newType;
        placePiece(player.row, player.col, { color: WHITE, type: player.type });
      }
    }

    function getLegalMoves(type, r, c){
      const moves = [];
      const add = (rr, cc) => {
        if (!inBounds(rr, cc)) return;
        const dest = board[rr][cc];
        if (!dest || dest.color === BLACK){
          out.push({ toRow: rr, toCol: cc });
        }
      };
      const out = [];
      if (type === "P"){
        const f1 = r + 1;
        const f2 = r + 2;
        if (inBounds(f1, c) && !board[f1][c]) out.push({toRow:f1, toCol:c});
        if (r === 0 && inBounds(f2, c) && !board[f1][c] && !board[f2][c]) out.push({toRow:f2, toCol:c});
        if (inBounds(f1, c-1) && isBlackAt(f1, c-1)) out.push({toRow:f1, toCol:c-1});
        if (inBounds(f1, c+1) && isBlackAt(f1, c+1)) out.push({toRow:f1, toCol:c+1});
      }
      else if (type === "K"){
        for (let dr = -1; dr <= 1; dr++){
          for (let dc = -1; dc <= 1; dc++){
            if (dr === 0 && dc === 0) continue;
            add(r + dr, c + dc);
          }
        }
      }
      else if (type === "N"){
        [[ 2, 1],[ 2,-1],[-2, 1],[-2,-1],[ 1, 2],[ 1,-2],[-1, 2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
      }
      else if (type === "B"){
        ray(r,c,[[1,1],[1,-1],[-1,1],[-1,-1]],out);
      }
      else if (type === "R"){
        ray(r,c,[[1,0],[-1,0],[0,1],[0,-1]],out);
      }
      else if (type === "Q"){
        ray(r,c,[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],out);
      }
      return out;
    }
    function ray(r,c,dirs,out){
      for (const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc;
        while (inBounds(rr,cc)){
          const d = board[rr][cc];
          if (!d){ out.push({toRow:rr,toCol:cc}); }
          else { if (d.color===BLACK) out.push({toRow:rr,toCol:cc}); break; }
          rr+=dr; cc+=dc;
        }
      }
    }

    function renderBoard(){
      const frag = document.createDocumentFragment();
      $board.innerHTML = "";
      for (let vRow = BOARD_ROWS - 1; vRow >= 0; vRow--){
        for (let c = 0; c < BOARD_COLS; c++){
          const sq = document.createElement("div");
          sq.className = "sq " + (((vRow + c) % 2 === 0) ? "light" : "dark");
          sq.dataset.row = String(vRow);
          sq.dataset.col = String(c);
          const p = board[vRow][c];
          if (p){
            const pieceEl = createPieceVisual(p, false);
            sq.appendChild(pieceEl);
          }
          frag.appendChild(sq);
        }
      }
      $board.appendChild(frag);
    }

    function createPieceVisual(p, isDrag){
      const span = document.createElement("span");
      const colorClass = (p.color === WHITE ? "white" : "black");
      span.className = "piece " + colorClass + (p.highlight ? " danger" : "");
      if (p.type === "P" || p.type === "p"){
        span.innerHTML = pawnSVG(p.color, p.highlight);
      } else {
        span.textContent = (p.color === WHITE ? WHITE_SYM[p.type] : BLACK_SYM[p.type.toLowerCase()]);
      }
      if (isDrag){
        span.style.display = "flex";
        span.style.alignItems = "center";
        span.style.justifyContent = "center";
        span.style.background = "rgba(0,0,0,0.0)";
      }
      return span;
    }

    // Pawn SVG; user (white) = rich royal gold, opposition (black) = rich bold blue; killer highlight = RED
    function pawnSVG(color, highlight=false){
      const isWhite = (color === WHITE);
      const fill = isWhite ? "#D4AF37" : (highlight ? "#D32F2F" : "#1976D2");
      const stroke = isWhite ? "#A67C00" : (highlight ? "#8B0000" : "#0D47A1");
      return `
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <circle cx="50" cy="24" r="14" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
          <path d="M35 40
                   C35 36, 65 36, 65 40
                   C65 46, 60 52, 54 56
                   C60 60, 62 66, 62 72
                   L38 72
                   C38 66, 40 60, 46 56
                   C40 52, 35 46, 35 40Z"
                fill="${fill}" stroke="${stroke}" stroke-width="2"/>
          <rect x="28" y="72" width="44" height="8" rx="2" ry="2" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
          <rect x="22" y="80" width="56" height="8" rx="2" ry="2" fill="${fill}" stroke="${stroke}" stroke-width="2"/>
        </svg>
      `;
    }

    // Position and populate the Game Over card over the board
    function showGameOverCard(){
      const card = document.getElementById('goCard');
      const rect = $boardShell.getBoundingClientRect();
      const squareW = rect.width / BOARD_COLS;

      // Leave half a chess square on left and right
      const left = rect.left + (squareW / 2);
      const width = rect.width - squareW;
      const top  = rect.top;
      const height = rect.height; // cover most of the chessboard (full height of board)

      card.style.left = `${left}px`;
      card.style.top  = `${top}px`;
      card.style.width = `${width}px`;
      card.style.height = `${height}px`;

      // Populate gold text entries
      const s = loadStats();
      const mostCaptures = s.mostTakes ?? 0;

      card.innerHTML = [
        `<div class="go-item-label">Score</div>`,
        `<div class="go-item-value">${score}</div>`,
        `<div class="go-item-label go-white">High Score</div>`,
        `<div class="go-item-value go-white">${high}</div>`,
        // blank line under High Score number
        `<div class="go-item-blank">&nbsp;</div>`,
        `<div class="go-item-label">Captures</div>`,
        `<div class="go-item-value">${captures}</div>`,
        `<div class="go-item-label go-white">Most Captures</div>`,
        `<div class="go-item-value go-white">${mostCaptures}</div>`
      ].join('');

      card.setAttribute('aria-hidden', 'false');
      $modal.classList.add('show');
    }

    function endGame(){
      gameOver = true;
      inGameOverSequence = false;
      updateStatsOnGameEnd(score, captures);
      showGameOverCard();
    }
    function hideModal(){ 
      const card = document.getElementById('goCard');
      if (card) card.setAttribute('aria-hidden', 'true');
      $modal.classList.remove("show"); 
    }

    function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
    function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    function shuffleCopy(a){ const b = a.slice(); shuffle(b); return b; }
    function countBlackPieces(){
      let n = 0;
      for (let r=0;r<BOARD_ROWS;r++){
        for (let c=0;c<BOARD_COLS;c++){
          const p = board[r][c];
          if (p && p.color === BLACK) n++;
        }
      }
      return n;
    }
    function isSquareAttackedByBlackOnBoard(b, r, c){
      for (let rr=0; rr<BOARD_ROWS; rr++){
        for (let cc=0; cc<BOARD_COLS; cc++){
          const p = b[rr][cc]; if (!p || p.color !== BLACK) continue;
          if (blackAttacksSquareOnBoard(p.type, rr, cc, r, c, b)) return true;
        }
      }
      return false;
    }
    function blackAttacksSquareOnBoard(type, br, bc, tr, tc, b){
      const dr = tr - br, dc = tc - bc;
      if (type === "p"){ return (tr === br - 1) && (tc === bc - 1 || tc === bc + 1); }
      if (type === "k"){ return Math.max(Math.abs(dr), Math.abs(dc)) === 1; }
      if (type === "n"){ return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2); }
      if (type === "b" || type === "r" || type === "q"){
        const dirs = [];
        if (type !== "r") dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        if (type !== "b") dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [drr,dcc] of dirs){
          let rr=br+drr, cc=bc+dcc;
          while (inBounds(rr, cc)){
            if (rr === tr && cc === tc) return true;
            const occ = b[rr][cc]; if (occ) break;
            rr += drr; cc += dcc;
          }
        }
        return false;
      }
      return false;
    }
  </script>
</body>
        </html>
